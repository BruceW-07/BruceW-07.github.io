[{"categories":["OI","解题报告"],"content":"Statement 传送门 Solution 考虑从朴素算法开始一步步推导。 我们考虑枚举做对的题目集合 $T$，并计算满足集合 $T$ 中题目总分大于等于 $n$ 的分数分配方案数。即 $$ \\begin{aligned} \\mathrm{Ans} \u0026= \\sum_{T} \\prod_{i \\in T}p_i \\prod_{i \\not \\in T} (1 - p_i) 【T 中题目总分大于等于 n 的合法分配方案数】 \\\\ \u0026= \\sum_{T} p(T) 【T 中题目总分大于等于 n 的合法分配方案数】 \\\\ \\end{aligned} $$ 而题目中对于“合法”的要求是：第 $i$ 道题目分配的分数不能超过 $a_i$。 给题目分配分数可以看做把“小球放进盒子”的模型，而对于这种“盒子对小球的个数有限制”的模型，我们一般会用容斥来计算方案数。 具体来说，就是枚举盒子的每个子集 $A$，钦定 $A$ 中的盒子超出了限制，然后其他盒子就随便放。 因此我们的式子可以化为。 $$ \\begin{aligned} \\mathrm{Ans} \u0026= \\sum_{T} p(T) \\sum_{A} (-1)^{|A|} 【将 N' 个球放进 M 个盒子，且 T 中的盒子的球总数大于等于 n' 的方案数】\\\\ \\end{aligned} $$ 其中 $N' = N - \\sum_{i \\in A} (a_i + 1),\\ n' = n - \\sum_{i \\in A \\cap T} (a_i + 1)$。 现在考虑怎么计算“【】”里描述的那个东西。 这种把球放进盒子里的方案数，我们通常会考虑隔板法。 然后这里为了方便描述，我们设前 $|T|$ 个隔板分别表示集合 $T$ 中的题目。因为球都是一样的，所以这样显然不会影响方案数的计算。 那么为了使得这 $|T|$ 个盒子中球数总和大于等于 $n'$，我们就要让第 $|T|$ 个隔板放在第 $n'$ 个球后面。 所以我们枚举第 $n'$ 个球之前的隔板数量，分别计算隔板放置方案，并求和即可。即 $$ \\sum_{t=0}^{|T|-1} \\binom{n' + t - 1}{t} \\binom{(N' + 1 - n') + (M - 1 - t) - 1}{M - 1 - t} = \\sum_{t=0}^{|T|-1} \\binom{n' + t - 1}{t} \\binom{N' - n' + M - 1 - t}{M - 1 - t} $$ 那么答案的计算式就可以进一步化为 $$ \\begin{aligned} \\mathrm{Ans} \u0026= \\sum_{T} p(T) \\sum_{A} (-1)^{|A|} \\sum_{t=0}^{|T|-1} \\binom{n' + t - 1}{t} \\binom{N' - n' + M - 1 - t}{M - 1 - t} \\\\ \\end{aligned} $$ 现在我们可以开始考虑如何计算了。 首先 $0 \\sim |T| - 1$ 属于可以接受的枚举范围，而前面的枚举 $T$ 和 $A$ 的操作我们可以考虑用 DP 计算系数。 所以大概思路就是对于每一个 $\\sum_{t=0}^{|T|-1}$ 的组合数求和操作，我们计算出它的系数，然后把所有结果累加。 那么我们就要观察这个组合数求和需要知道哪些变量，并根据这些变量来设置 DP 状态。 $\\sum_{t=0}^{|T|-1} \\binom{n' + t - 1}{t} \\binom{N' - n' + M - 1 - t}{M - 1 - t}$ 这个式子中，只有 $M$ 是已知的，所以我们还需要知道 $|T|,N',n'$。 所以我们设 $f_{i,j,k,l}$ 表示考虑到第 $i$ 道题，$|T|=j, N'=k, n'=l$ 的系数总和。转移只需枚举第 $i$ 道题目是否加入 $T$ 集合以及是否加入 $A$ 集合即可。 然后由于 $N'$ 等于 $N$ 减去若干个 $a_i + 1$，$n'$ 等于 $n$ 减去若干个 $a_i + 1$，而题目中有条件：存在 $d$，满足对于所有 $i$ 都有 $d | (a_i+1)$，并且 $N \\le 100 \\times d$。 所以我们可以把 $k,l$ 的意义改为 $N' = N - k \\times d, n' = n - l \\times d$。这样 DP 的复杂度就降为 $O(M^2 (\\frac{N}{d})^2) \\approx 10^8$。 而最后统计答案的复杂度也是 $O(M^2 (\\frac{N}{d})^2)$ 的，所以总复杂度也是 $O(M^2 (\\frac{N}{d})^2)$ 的。 最后统计答案，组合数求和时，可以需要特判一下 $n' \\le 0$ 的情况。 Summary 这道题的解题逻辑还是比较清晰的，唯一不太想得到的可能就只有【将 N' 个球放进 M 个盒子，且 T 中的盒子的球总数大于等于 n' 的方案数】这个东西。 但问题是推式子的时候比较难冷静下来，而且容易去想一些奇奇怪怪的东西，从而绕很多弯路，而这种推导的时候一旦方向偏了就比较难搞了。 Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; const int _ = 1e2 + 7; const int mod = 998244353; int M, d, N, n, a[_], aa[_], p[_], f[_][_][_], g[_][_][_], inv[_], C1[_], C2[_], ans; int main() { cin \u003e\u003e M \u003e\u003e d \u003e\u003e N \u003e\u003e n; for (int i = 1; i \u003c= M; ++i) { scanf(\"%d%d\", \u0026a[i], \u0026p[i]); aa[i] = (a[i] + 1) / d; } inv[1] = 1; for (int i = 2; i \u003c= M; ++i) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; f[0][0][0] = 1; for (int i = 1; i \u003c= M; ++i) { for (int j = 0; j \u003c= i; ++j) for (int k = 0; k \u003c= N / d; ++k) { for (int l = 0; l \u003c= k; ++l) { unsigned long long t1 = 0, t2 = 0, t3 = 0, t4 = 0; if (j) t1 = 1ll * f[j - 1][k][l] * p[i]; if (j and l \u003e= aa[i] and k \u003e= aa[i]) t2 = 1ll * f[j - 1][k - aa[i]][l - aa[i]] * p[i]; if (k \u003e= aa[i]) t3 = 1ll * f[j][k - aa[i]][l] * (1 - p[i] + mod); t4 = 1ll * f[j][k][l] * (1 - p[i] + mod); g[j][k][l] = ((t1 + t4) % mod + mod - (t2 + t3) % mod) % mod; } } memcpy(f, g, sizeof f), memset(g, 0, sizeof g); } for (int j = 1; j \u003c= M; ++j) for (int k = 0; k \u003c= N / d; ++k) for (int l = 0; l \u003c= k; ++l) { if (l * d \u003e N) continue; int NN = N - k * d, nn = max(0, n - l * d); if (nn \u003e NN) continue; C1[0] = 1, C2[j - 1] = 1; for (int t = 1; t \u003c= j - 1; ++t) C1[t] = 1ll * C1[t - 1] * (nn - 1 + t) % mod * inv[t] % mod; for (int t = 1; t \u003c= M - 1 - (j - 1); ++t) C2[j - 1] = 1ll * C2[j - 1] * (NN - nn + t) % mod * inv[t] % mod; for (int t = j - 2; t \u003e= 0; --t) C2[t] = 1ll * C2[t + 1] * (NN - nn + M - 1 - t) % mod * inv[M - 1 - t] % mod; if (nn == 0) { ans = (ans + 1ll * C2[0] * f[j][k][l] % mod) % mod; continue; } int res = 0; for (int t = 0; t \u003c j; ++t) res = (res + 1ll * C1[t] * C2[t]) % mod; ans = (ans + 1ll * res * f[j][k][l] % mod) % mod; } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-02-26","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday3%E5%BC%B5%E5%A3%AB%E8%B6%85%E4%BD%A0%E6%98%A8%E5%A4%A9%E6%99%9A%E4%B8%8A%E5%88%B0%E5%BA%95%E6%8A%8A%E6%88%91%E5%AE%B6%E9%91%B0%E5%8C%99%E6%94%BE%E5%9C%A8%E5%93%AA%E4%BA%86/:0:0","tags":["OI","解题报告","计数","DP","容斥","小球","国集集训"],"title":"[解题报告][2020五校国集集训Day3]張士超你昨天晚上到底把我家鑰匙放在哪了？","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday3%E5%BC%B5%E5%A3%AB%E8%B6%85%E4%BD%A0%E6%98%A8%E5%A4%A9%E6%99%9A%E4%B8%8A%E5%88%B0%E5%BA%95%E6%8A%8A%E6%88%91%E5%AE%B6%E9%91%B0%E5%8C%99%E6%94%BE%E5%9C%A8%E5%93%AA%E4%BA%86/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 Solution ","date":"2021-02-25","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/:0:0","tags":["OI","解题报告","DP","DP套DP","计数","卢卡斯定理","国集集训"],"title":"[解题报告][2020五校国集集训Day2]高维游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"问题转化 由于是求 $\\bmod 2$ 意义下的方案数, 所以我们考虑先用卢卡斯定理来简化问题. 假设我们先枚举出每一维走的步数, 设向量 $w$, 它的第 $i$ 维元素 $w_i$ 表示在第 0 阶段中在第 $i$ 维走的步数. 那么满足向量 $w$ 的游走方案为. $$ \\binom{t_0}{w_1, w_2, \\cdots, w_m} \\prod_{i = 1}^m \\binom{t_i}{w_i} $$ 展开后也就是 $$ \\binom{t_0}{w_1} \\binom{t_0 - w_1}{w_2} \\binom{t_0 - w_1 - w_2 - \\cdots - w_{m - 1}}{w_m} \\prod_{i = 1}^m \\binom{t_i}{w_i} $$ 根据卢卡斯定理 $\\binom{n}{m} \\equiv \\binom{\\lfloor n / 2 \\rfloor}{\\lfloor m / 2 \\rfloor} \\binom{n \\bmod 2}{m \\bmod 2} \\pmod 2$, 如果我们要使上述式子为 1, 则要满足 对于所有 $i \\in [1,m]$, 满足 $w_i$ 按位或 $t_i$ 的结果等于 $t_i$, 这里我们称为 $w_i \\subseteq t_i$. 对于所有 $i \\in [1, m]$, 满足 $w_i \\subseteq t_0 - \\sum_{j = 1}^{i - 1} w_j$, 直观上来说, 就是 $w_{1 \\cdots m}$ 构成了 $t_0$ 的一个**不完全划分** . 那么我们可以通过一个类似数位DP的过程来计算满足这个条件的游走方案数. ","date":"2021-02-25","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/:1:0","tags":["OI","解题报告","DP","DP套DP","计数","卢卡斯定理","国集集训"],"title":"[解题报告][2020五校国集集训Day2]高维游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"DP 首先很容易想到一个 naive 的 DP: 设 $f_{i,v}$ 表示进行到二进制第 $i$ 为, 得到的总代价为 $v$ 的游走方案在模2意义下的结果. 转移的话只需枚举每一位取 $1\\sim m$ 中的哪一维 (或者不选) 即可, 复杂度为 $O(tm\\log t_0)$. ","date":"2021-02-25","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/:2:0","tags":["OI","解题报告","DP","DP套DP","计数","卢卡斯定理","国集集训"],"title":"[解题报告][2020五校国集集训Day2]高维游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"优化 注意到每一步游走的代价最多只有 $m$, 而 $m \\le 10$, 所以对于当前的 $i$, 合法的代价 $v$ 不会大出 $2^i$ 太多. 并且假设我们把 $v$ 按二进制位考虑, $v$ 中小于 $2^{i + 1}$ 的部分已经固定了, 在之后的转移中都不会改变, 所以我们可以认为只有 $v$ 中大于等于 $2^{i + 1}$ 的部分才是对转移有用的. 那么我们可以考虑把 $v$ 表示成 $v' + q2^{i + 1} (v' \\le 2^{i + 1})$ 的形式. 然后因为 $v \\le \\sum_{j = 1}^i m2^j \u003c m2^{i+1}$, 所以 $q \\in [0, m)$. 然后重新设一个DP状态: $f_{i, v', q}' = f_{i,v}$, 转移是类似的. 然后由于后面的转移只与 $q$ 有关, 所以对于一对 $(v_1, v_2)$, 若满足对于所有 $q \\in [0, m)$, 都有 $f_{i, v_1,q} = f_{i, v_2, q}$, 那么它们后面的转移方向都是一样的, 所以我们可以考虑把这两个状态合并起来以简化复杂度. 所以我们新设一个DP: $g_{i, S}$ 表示进行到第 $i$ 位, 对于所有 $q \\in [0, m)$ 满足 $f_{i,v,q} = S_q$ 的 $v$ 的数量. 其中 $S_q$ 表示 $S$ 的二进制表示下的第 $q$ 位数字. 转移的话, 假设当前得出了 $g_{i - 1, S}$, 我们枚举 $a,b$, 表示 $S$ 中的第 $a$ 位以及当前选择第 $b$ 维进行游走. 那么总代价就是 $$ v' + (a + b)2^{i} = v' + r2^i + ((a + b) » 1))2^{i + 1} = v' + r2^i + c2^{i + 1} $$ 我们设两个变量 $T_0, T_1$, 若 $r = 0$, 则在 $T_0$ 的第 $c$ 位异或上 1, 否则就在 $T_1$ 的第 $c$ 位异或上 1. 最后转移到 $g_{i, T_0}$ 和 $g_{i, T_1}$ 即可. 这样复杂度为 $O(2^m m^2 \\log t_0) \\approx 3 \\times 10^6$, 再乘上 $200$ 组测试数据, $\\approx 6 \\times 10^8$, 1s 的时限内显然过不了. 再继续考虑优化转移过程, 我们发现枚举 $a,b$ 后, 得到的 $r$ 只有 $0,1$ 两种可能, 而 $c = (a + b) » 1 = \\lfloor (a + b) / 2 \\rfloor$ 也只有两种可能 : $\\lfloor a / 2 \\rfloor + \\lfloor b / 2 \\rfloor$ 或 $\\lfloor a / 2 \\rfloor + \\lfloor b / 2 \\rfloor + 1$. 只需要把 $a,b$ 分奇偶讨论一下就行了. 所以我们可以设两个变量 $S_0, S_1$, 分别把 $S$ 中每个 $a$ 为偶和 $a$ 为奇的情况记录下来, 然后枚举每个 $b$, 按奇偶讨论转移即可. 复杂度为 $O(2^m m \\log t_0) \\approx 3 \\times 10^5$. 在 $200$ 组数据的情况下可以通过. ","date":"2021-02-25","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/:3:0","tags":["OI","解题报告","DP","DP套DP","计数","卢卡斯定理","国集集训"],"title":"[解题报告][2020五校国集集训Day2]高维游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; const int _ = 10 + 7; const int __ = (1 \u003c\u003c 10) + 7; const int L = 30; int m, t[_]; long long g[__], h[__]; void Solve() { cin \u003e\u003e m; for (int i = 0; i \u003c= m; ++i) scanf(\"%d\", \u0026t[i]); memset(g, 0, sizeof g), memset(h, 0, sizeof h); g[1] = 1; for (int i = 0; i \u003c= L; ++i) { for (int s = 1; s \u003c (1 \u003c\u003c m); ++s) { int s0 = 0, s1 = 0, t0 = 0, t1 = 0; for (int a = 0; a \u003c m; ++a) (a \u0026 1 ? s1 : s0) |= (s \u003e\u003e a \u0026 1) \u003c\u003c (a / 2); for (int b = 0; b \u003c= m; ++b) { if (b and !((t[b] \u0026 t[0]) \u003e\u003e i \u0026 1ll)) continue; if (b \u0026 1) t0 ^= s1 \u003c\u003c (b / 2 + 1), t1 ^= s0 \u003c\u003c (b / 2); else t0 ^= s0 \u003c\u003c (b / 2), t1 ^= s1 \u003c\u003c (b / 2); } h[t0] += g[s], h[t1] += g[s]; } memcpy(g, h, sizeof h), memset(h, 0, sizeof h); } long long ans = 0; for (int i = 1; i \u003c (1 \u003c\u003c m); ++i) for (int j = 0; j \u003c m; ++j) if (i \u003e\u003e j \u0026 1) ans += g[i]; cout \u003c\u003c ans \u003c\u003c endl; } int main() { int T; cin \u003e\u003e T; while (T--) Solve(); return 0; } ","date":"2021-02-25","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/:4:0","tags":["OI","解题报告","DP","DP套DP","计数","卢卡斯定理","国集集训"],"title":"[解题报告][2020五校国集集训Day2]高维游走","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A2020%E4%BA%94%E6%A0%A1%E5%9B%BD%E9%9B%86%E9%9B%86%E8%AE%ADday2%E9%AB%98%E7%BB%B4%E6%B8%B8%E8%B5%B0/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 有一个长度为 \\(n\\) 初始元素全为 \\(0\\) 的序列 \\(P\\). 进行 \\(K\\) 操作, 每次选择 \\(a_i\\) 个不同的元素将其 \\(+1\\), 两次不同操作所选择的元素可以相同. 求 \\(K\\) 次操作后 \\(P\\) 中元素乘积的期望乘以总方案数. \\(n \\le 1000, K \\le 20\\). ","date":"2021-02-24","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aat5742cookie-distribution/:1:0","tags":["OI","解题报告","计数","DP","AtCoder"],"title":"[解题报告][AT5742]Cookie Distribution","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aat5742cookie-distribution/"},{"categories":["OI","解题报告"],"content":"Solution 乘积算期望比较难搞, 所以首先把它进行转化. 使用 \\(a = \\binom{a}{1}\\) 这个套路, 得到 \\[ \\prod_{i = 1}^n p_i = \\prod_{i = 1}^n \\binom{p_i}{1} \\] 而 \\( \\prod_{i = 1}^n \\binom{p_i}{1} \\) 的组合意义可以解释为: 对于每个 \\(i\\) 在选择到了 \\(i\\) 的若干次操作中选择一个操作的方案数. 然后我们把对象转换一下, 假设先枚举每个 \\(i\\) 所选择的操作 \\(q_i\\), 并设 \\(x_i = \\sum_{j = 1}^n [q_j = i]\\), 那么满足 \\(\\{q\\}\\) 的操作方案数量为 \\[ \\prod_{i = 1}^K \\binom{n - x_i}{a_i - x_i} \\] 那么假设我们枚举序列 \\(\\{x\\}\\), 则答案为 \\[ \\sum_{\\{x\\}} \\binom{n}{x_1, x_2, \\cdots, x_K} \\sum_{i = 1}^K \\binom{n - x_i}{a_i - x_i} \\] 这个可以使用 DP 计算. 具体来说, 就是设 \\(f_{i,j}\\) 表示考虑到第 \\(i\\) 次操作, 共钦定了 \\(j\\) 个节点的 \\(q\\) 的贡献总和. 转移方程为 \\[ f_{i, j} = \\sum_{k = 0}^{\\min(j, a_i)} f_{i - 1, j - k} \\binom{n - k}{a_i - k} \\frac{1}{k!} \\] 最后答案即为 \\(n!\\ \\times f_{K, n}\\). 复杂度为 \\(O(n^2K)\\). ","date":"2021-02-24","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aat5742cookie-distribution/:2:0","tags":["OI","解题报告","计数","DP","AtCoder"],"title":"[解题报告][AT5742]Cookie Distribution","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aat5742cookie-distribution/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ciostream\u003e using namespace std; const int _ = 20 + 7; const int __ = 1e3 + 7; const int mod = 1e9 + 7; int n, K, a[_], fac[__], ifac[__], inv[__], f[_][__]; int C(int n, int m) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; } int main() { cin \u003e\u003e n \u003e\u003e K; for (int i = 1; i \u003c= K; ++i) cin \u003e\u003e a[i]; fac[0] = ifac[0] = inv[1] = 1; for (int i = 1; i \u003c= n; ++i) { fac[i] = 1ll * fac[i - 1] * i % mod; if (i != 1) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod; } f[0][0] = 1; for (int i = 1; i \u003c= K; ++i) for (int j = 0; j \u003c= n; ++j) for (int k = 0; k \u003c= min(a[i], j); ++k) f[i][j] = (f[i][j] + 1ll * f[i - 1][j - k] % mod * ifac[k] % mod * C(n - k, a[i] - k) % mod) % mod; cout \u003c\u003c 1ll * f[K][n] * fac[n] % mod \u003c\u003c endl; return 0; } ","date":"2021-02-24","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aat5742cookie-distribution/:3:0","tags":["OI","解题报告","计数","DP","AtCoder"],"title":"[解题报告][AT5742]Cookie Distribution","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aat5742cookie-distribution/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 给定集合 \\( \\{0, 1, 2, \\cdots, 2^n - 1\\} \\), 求满足按位与后二进制中 \\(1\\) 的个数为 \\(4\\) 的倍数的子集 \\(T\\) 的个数. \\(n \\le 10^7\\). 70pts subtask: \\(n \\le 10^5\\). ","date":"2021-02-22","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/:1:0","tags":["计数","推式子","容斥","单位根反演","loj"],"title":"[解题报告][loj6358]前夕","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/"},{"categories":["OI","解题报告"],"content":"Solution 设 \\(f_i\\) 表示 \\(\\{0, 1, \\cdots, 2^i - 1\\}\\) 中满足按位与后 \\(1\\) 的个数为 \\(0\\) 的 非空 子集数量, 则有 \\[ \\mathrm{ans} = 1 + \\sum_{i = 0}^{\\lfloor \\frac{n}{4} \\rfloor} \\binom{n}{4i} f_{n - 4i} \\] (其中 \\(1\\) 表示的是空集.) \\(f_i\\) 的计算可以使用容斥. 我们每次钦定若干个位置, 使得按位与后这些位置为 \\(1\\), 则可以列出式子 \\[ f_i = \\sum_{j = 0}^i (-1)^j \\binom{i}{j} (2^{2^{i - j}} - 1) \\] 把组合数展开后就可以写成卷积的形式, 使用 NTT 就可以做到 \\(O(n \\log n)\\) 的复杂度, 可以通过 \\(n \\le 10^5\\) 的 subtask. 推一下式子, 发现 \\(f\\) 的计算似乎没有什么更好的方法, 那么我们考虑把 \\(f\\) 扔回答案计算式中, 再对整个式子考虑优化. 而上面描述的计算式中, 我们发现 \\(4i\\) 这个东西不太优美, 因为它使得 \\(f\\) 不连续了, 可能会导致推式子的过程中出现一些问题. 所以我们把它改为 \\([4 | i]\\), 并考虑使用单位根反演. 原式为 \\[ \\begin{aligned} \\mathrm{ans} - 1 \u0026= \\sum_{i = 0}^n [4 | i] \\binom{n}{i} f_{n - i} \\\\ \u0026= \\sum_{i = 0}^n [4 | n - i] \\binom{n}{i} f_{i} \\\\ \u0026= \\sum_{i = 0}^n [4 | n - i] \\binom{n}{i} \\sum_{j = 0}^i (-1)^j \\binom{i}{j} (2^{2^{i - j}} - 1) \\\\ \\end{aligned} \\] \\((2^{2^{i - j}} - 1)\\) 这个东西长得过于丑陋, 所以我们考虑把它扔到前面来枚举. \\[ \\begin{aligned} \\mathrm{ans} - 1 \u0026= \\sum_{i = 0}^n [4 | n - i] \\binom{n}{i} \\sum_{j = 0}^i (-1)^{i - j} \\binom{i}{j} (2^{2^j} - 1) \\\\ \u0026= \\sum_{j = 0}^n (2^{2^j} - 1) \\sum_{i = j}^n [4 | n - i] (-1)^{i - j} \\binom{n}{i} \\binom{i}{j} \\\\ \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\sum_{i = j}^n [4 | n - i] (-1)^{i - j} \\binom{n - j}{i - j} \\\\ \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\sum_{i = 0}^{n - j} [4 | n - i - j] (-1)^i \\binom{n - j}{i} \\\\ \\end{aligned} \\] 然后把 \\([4 | i + j]\\) 用单位根反演换掉, \\[ \\begin{aligned} \\mathrm{ans} - 1 \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\sum_{i = 0}^{n - j} (-1)^i \\binom{n - j}{i} \\frac{1}{4} \\sum_{k = 0}^3 \\omega_{4}^{k(n - i - j)} \\\\ \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\frac{1}{4} \\sum_{k = 0}^3 \\omega_{4}^{k(n - j)} \\sum_{i = 0}^{n - j} (-1)^i \\binom{n - j}{i} \\omega_{4}^{-ki} \\\\ \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\frac{1}{4} \\sum_{k = 0}^3 \\omega_{4}^{k(n - j)} \\sum_{i = 0}^{n - j} \\binom{n - j}{i} (- \\omega_{4}^{-k})^i \\\\ \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\frac{1}{4} \\sum_{k = 0}^3 \\omega_{4}^{k(n - j)} (1 - \\omega_4^{-k})^{n - j} \\\\ \u0026= \\sum_{j = 0}^n \\binom{n}{j} (2^{2^j} - 1) \\frac{1}{4} \\sum_{k = 0}^3 (\\omega_{4}^{k} (1 - \\omega_4^{-k}))^{n - j} \\\\ \\end{aligned} \\] 后面那坨东西可以预处理, 前面的组合数和 \\(2\\) 的若干次方可以递推, 所以总复杂度为 \\(O(n)\\), 可以通过全部数据. ","date":"2021-02-22","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/:2:0","tags":["计数","推式子","容斥","单位根反演","loj"],"title":"[解题报告][loj6358]前夕","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003ciostream\u003e using namespace std; const int _ = 1e7 + 7; const int mod = 998244353; int n, inv[_], pww[4][_], w[4]; int Pw(int a, int p) { int res = 1; while (p) { if (p \u0026 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; p \u003e\u003e= 1; } return res; } void pls(int \u0026x, long long y) { x = (x + y) % mod; } int main() { cin \u003e\u003e n; inv[1] = 1; for (int i = 2; i \u003c= n; ++i) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; for (int k = 0; k \u003c 4; ++k) w[k] = Pw(Pw(3, (mod - 1) / 4), k); for (int k = 0; k \u003c 4; ++k) { pww[k][0] = 1, pww[k][1] = 1ll * w[k] * (1 - w[(4 - k) % 4] + mod) % mod; for (int i = 2; i \u003c= n; ++i) pww[k][i] = 1ll * pww[k][i - 1] * pww[k][1] % mod; } int C = 1, pw = 2, ans = 0; for (int j = 0; j \u003c= n; ++j) { int res = 0; for (int k = 0; k \u003c 4; ++k) pls(res, pww[k][n - j]); pls(ans, 1ll * C * (pw - 1 + mod) % mod * res % mod); C = 1ll * C * (n - j) % mod * inv[j + 1] % mod; pw = 1ll * pw * pw % mod; } cout \u003c\u003c (1ll * ans * Pw(4, mod - 2) % mod + 1) % mod \u003c\u003c endl; return 0; } ","date":"2021-02-22","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/:3:0","tags":["计数","推式子","容斥","单位根反演","loj"],"title":"[解题报告][loj6358]前夕","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/"},{"categories":["OI","解题报告"],"content":"Postscript 这道题我从 14:30 开始推, 然后在托腮的 \"题解\" 帮助下在 15:30 推完了, 上了个洗手间后把代码写了, 然后没过样例, 然后发现式子推错了, 然后重新推式子, 然后推完了, 然后代码写完了, 然后又没过样例, 然后写了个暴力, 然后发现是组合数递推出错了, 然后就 A 了, 然后已经 17:00 了. 再论wz做题量这么少的原因. ","date":"2021-02-22","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/:4:0","tags":["计数","推式子","容斥","单位根反演","loj"],"title":"[解题报告][loj6358]前夕","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aloj6358%E5%89%8D%E5%A4%95/"},{"categories":["OI","解题报告"],"content":"Statement 题面 一个长度为 \\(n\\) 的序列 \\( \\{ a \\} \\), 有 \\(Q\\) 个形如 \\((l, r, )\\) 的询问, 每次需要回答在区间 \\([l,r]\\) 内选择 恰好 \\(k\\) 个 不相交区间 的元素和最大值. \\( n, Q \\le 35000, |a_i| \\le 35000\\). ","date":"2021-02-19","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A300iq-contest-2-hhonorable-mention/:1:0","tags":["OI","解题报告","数据结构","凸包","凸优化","闵可夫斯基和","CodeForces","300iq"],"title":"[解题报告][300iq Contest 2 H]Honorable Mention","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A300iq-contest-2-hhonorable-mention/"},{"categories":["OI","解题报告"],"content":"Solution 先考虑对于单个询问怎么做. 假设询问区间为 \\([1, n]\\), 设 DP 状态 \\(f_{i, j}\\) 为考虑到第 \\(i\\) 位, 选择了 \\(j\\) 个区间的最大值. 容易得到转移. \\[ f_{i, j} = \\max(f_{i - 1, j}, \\max_{k = 0}^{i - 1} f_{k, j - 1} + sum_{i} - sum_{k}) \\] 其中 \\(\\{ sum \\}\\) 是 \\(\\{ a \\}\\) 的前缀和. 加上一个前缀最大值优化, 我们就得到了一个 \\(O(n^2Q)\\) 的做法. 考虑怎么优化. 如果你见得多或者直觉比较好, 大概可以猜出 \\(F(x) = f_{n, x} (x \\in [1, n])\\) 这个函数可能是凸的. 证明函数凸性的话就考虑是否能建出一个费用流模型, 如果可以, 就表示它一定是凸的. 因为最大费用流的过程中我们总是先拓展费用最大的流, 所以每次拓展的流的费用是递减的, 就相当于函数的变化量 \\( \\Delta \\) 是递减的, 也就表明这函数是个凸函数. 设 \\((u, v, c, w)\\) 为一条从 \\(u\\) 连向 \\(v\\) 的容量为 \\(c\\), 费用为 \\(w\\) 的边. 考虑把每个元素 \\(a_i\\) 拆成一个入点 \\(u_i\\) 和出点 \\(v_i\\), 连接 \\((u_i, v_i, 1, a_i)\\). 然后 \\( \\forall i \\in [1, n - 1] \\), 连接 \\((v_i, u_{i + 1}, 1, 0)\\); \\(\\forall i \\in [1, n]\\), 连接 \\((S, u_i, 1, 0), (v_i, T, 1, 0)\\). 这样就把费用流模型建好了, 所以函数 \\(F(x)\\) 是凸的, 所以我们可以用凸优化来优化它的计算. 假设我们当前要求 \\((l, r, k)\\), 那么我们二分一个斜率 \\(mid\\), 并找出该直线的在凸包上的切点 \\((x, F(x)\\), 若 \\(x \\ge k\\), 则增大 \\(mid\\), 否则减小. 然后找切点就相当于找凸包上距离斜率为 \\(mid\\) 的直线最近的点, 也就是 \\( x \\cdot mid - F(x) \\) 最小的点, 也就是 \\((x, F(x) - x \\cdot mid) \\) 的最高点. 那么我们考虑怎么求 \\(F(x) - x \\cdot mid\\) 的最大值. 设 \\( g_{i} \\) 表示考虑到 \\(i\\) 时的答案, 并且 \\(g_i\\) 是一个 \\(std::pair\\), 第一维记的是 \\(F(x) - x \\cdot mid\\), 第二维记的是 \\(x\\). 那么容易写出转移方程. \\[ g_i = \\max(g_{i - 1}, \\max_{k = 1}^{i - 1} g_k + (sum_i - sum_k, 1)) \\] 同样, 使用前缀和优化的话一次 DP 可以做到 \\(O(n)\\), 所以总复杂度为 \\(O(nQ \\log value)\\). 然而这个 DP 和正解好像并没有什么关系. 想要做到更优的复杂度, 我们可以考虑用一个数据结构来维护凸包. 这里我们使用线段树. 对于线段树上的一个节点 \\(k\\) 和它所代表的区间 \\([l, r]\\), 我们维护出以 \\([l, r]\\) 为选取区间时的 \\(F(x), x \\in [1, r - l + 1]\\). 这个东西还是比较好弄的, 就是在合并子区间的时候用闵可夫斯基和维护一下即可. 闵可夫斯基和就相当于利用函数的凸性来加速背包合并的过程. 具体来说就是对两个子区间的凸包维护分别维护一个指针, 每次将指针所指向的两个值之和贡献给父区间的对应位置, 然后将变化量 \\(\\Delta\\) 更大的一个指针往后移动一位. 然后这里有个要注意的地方是, 如果左子区间选了最右边的一个元素, 右子区间也选了最左边的一个元素, 那么合并的时候可以认为少选择了一个区间. 所以我们对每个节点实际上要维护 4 个凸包, 分别表示左右端点的元素是否选择的情况下的 \\(F(x)\\). 这样我们就可以 \\(O(n \\log n)\\) 建出来一棵线段树. 对于查询的话, 我们还是按照凸优化的套路. 先把查询区间 \\([L, R]\\) 在线段树上对应的区间抠出来, 然后二分一个 \\(mid\\), 在每个区间的凸包上都二分找到斜率为 \\(mid\\) 的直线与该凸包的切点 (对于 4 个凸包都要找), 然后在对这些切点所对应的值做一个 01 背包, 求出最大值, 那么就找到了区间 \\([L, R]\\) 内 \\(F(x) - x \\cdot mid\\) 的最大值, 然后接着二分即可. 但是这样的话一次询问的复杂度是 \\(O(\\log^ n \\log value)\\) 的 (\\( O(\\log n)\\) 个线段树上的区间, 找切点一个 \\(\\log\\), 凸优化的二分又一个 \\(log\\)), 无法通过. 优化的话我们考虑使用 整体二分 把 在线段树区间的凸包上找切点 的复杂度优化掉. 我们对所有询问一起进行凸优化, 然后在整体二分进行到某一层的时候, 我们按照 \\(mid\\) 从大到小枚举每个询问 (这个 \\(mid\\) 指的是它在凸优化过程中二分出来的斜率 \\(mid\\), 而不是区间中点.), 然后把 在线段树区间的凸包上找切点 的二分改为 维护一个指针每次暴力移动. 然后因为对于同一个凸包来说, 斜率 \\(mid\\) 越小, 则它在该凸包上的切点位置越靠右 (画图理解), 所以对于线段树上每个区间的凸包, 它的指针的移动是单调的. 也就是说, 对于整体二分中的每一层, 线段树上所有指针的总移动次数是 \\(O(n \\log n)\\) 的, 那么总复杂度就是 \\(O(n \\log n \\log value)\\), 可以通过. 实现的时候由于线段树上的凸包需要用 \\(std::vector\\) 维护, 而这东西的常数又比较大, 所以不要在整体二分的每一层都对线段树上所有节点的凸包都移动, 而是只要访问到一个节点后移动它的凸包上的指针就行了. 还有凸优化二分的时候会出现凸包上三点贡献的情况, 然后按照上述的二分方法, 这时我们会将 \\(mid\\) 指向这些共线的点中最右边的那个点, 所以我们对于一个询问 \\((l, r, k)\\), 在所有 \\(x \\ge k\\) 的情况下 (\\(x\\) 就是切点横坐标) 都要覆盖答案的值. (因为二分进行到越后面, 得到的 \\(x\\) 就会越接近于 \\(k\\), 所以最后一个满足 \\(x \\ge k\\) 的 \\(x\\) 也就是最小的 \\(x\\), 也就是与 \\((k, F(k))\\) 共线的 \\((x, F(x))\\).) ","date":"2021-02-19","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A300iq-contest-2-hhonorable-mention/:2:0","tags":["OI","解题报告","数据结构","凸包","凸优化","闵可夫斯基和","CodeForces","300iq"],"title":"[解题报告][300iq Contest 2 H]Honorable Mention","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A300iq-contest-2-hhonorable-mention/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003cctime\u003e#include \u003ciostream\u003e#include \u003cvector\u003e #define pb push_back #define sz(x) (int)(x).size() #define mkp make_pair #define fi first #define se second using namespace std; typedef long long ll; const int _ = 35000 + 7; const int __ = 1e6 + 7; const ll inf = 1e18; int n, Q, a[_], tot; struct QUE { int l, r, k; int ans; } qu[_]; vector\u003cll\u003e f[__][2][2]; pair\u003cll, int\u003e g[2]; int pt[__][2][2], sz[__]; void upd(ll \u0026x, ll y) { x = max(x, y); } namespace SGT { #define mid ((l + r) \u003e\u003e 1) #define ls(k) (k \u003c\u003c 1) #define rs(k) (k \u003c\u003c 1 | 1) void Merge(int k, int len1, int len2, int a, int b, int c, int d) { int p1 = 1, p2 = 1; while (p1 \u003c= len1 and p2 \u003c= len2) { ll tmp = f[ls(k)][a][b][p1] + f[rs(k)][c][d][p2]; upd(f[k][a][d][p1 + p2], tmp); if (b and c) upd(f[k][a][d][p1 + p2 - 1], tmp); ll d1 = f[ls(k)][a][b][p1 + 1] - f[ls(k)][a][b][p1]; ll d2 = f[rs(k)][c][d][p2 + 1] - f[rs(k)][c][d][p2]; if (p1 != len1 and (p2 == len2 or d1 \u003e= d2)) ++p1; else ++p2; } } void Build(int k, int l, int r) { tot = max(tot, k), sz[k] = r - l + 1; for (int i = 0; i \u003c 2; ++i) for (int j = 0; j \u003c 2; ++j) { f[k][i][j].resize(r - l + 2); for (int t = 1; t \u003c= r - l + 1; ++t) f[k][i][j][t] = -inf; } if (l == r) return (void)(f[k][1][1][1] = a[l]); Build(ls(k), l, mid); Build(rs(k), mid + 1, r); for (int i = 0; i \u003c 2; ++i) { for (int j = 1; j \u003c= mid - l + 1; ++j) upd(f[k][i][0][j], max(f[ls(k)][i][0][j], f[ls(k)][i][1][j])); for (int j = 1; j \u003c= r - mid; ++j) upd(f[k][0][i][j], max(f[rs(k)][0][i][j], f[rs(k)][1][i][j])); } for (int a = 0; a \u003c 2; ++a) for (int b = 0; b \u003c 2; ++b) for (int c = 0; c \u003c 2; ++c) for (int d = 0; d \u003c 2; ++d) Merge(k, mid - l + 1, r - mid, a, b, c, d); } void Move(int k, int i, int j, int slope) { int p = pt[k][i][j]; while (p + 1 \u003c= sz[k] and slope \u003c= f[k][i][j][p + 1] - f[k][i][j][p]) ++p; pt[k][i][j] = p; } void Query(int k, int l, int r, int x, int y, int cst) { if (l \u003e= x and r \u003c= y) { pair\u003cll, int\u003e t0 = mkp(-1e18, 0), t1 = mkp(-1e18, 0); for (int i = 0; i \u003c 2; ++i) for (int j = 0; j \u003c 2; ++j) Move(k, i, j, cst); for (int i = 0; i \u003c 2; ++i) { for (int j = 0; j \u003c 2; ++j) { int p0 = pt[k][j][0], p1 = pt[k][j][1]; ll f0 = f[k][j][0][p0], f1 = f[k][j][1][p1]; if (i and j) { t0 = max(t0, mkp(g[i].fi + f0 - 1ll * (p0 - 1) * cst, g[i].se + p0 - 1)); t1 = max(t1, mkp(g[i].fi + f1 - 1ll * (p1 - 1) * cst, g[i].se + p1 - 1)); } t0 = max(t0, mkp(f0 - 1ll * p0 * cst, p0)); t1 = max(t1, mkp(f1 - 1ll * p1 * cst, p1)); t0 = max(t0, mkp(g[i].fi + f0 - 1ll * p0 * cst, g[i].se + p0)); t1 = max(t1, mkp(g[i].fi + f1 - 1ll * p1 * cst, g[i].se + p1)); } if (g[i].se) t0 = max(t0, g[i]); } g[0] = t0, g[1] = t1; return; } if (x \u003c= mid) Query(ls(k), l, mid, x, y, cst); if (y \u003e mid) Query(rs(k), mid + 1, r, x, y, cst); } #undef mid #undef ls #undef rs } pair\u003cpair\u003cint, int\u003e, int\u003e p[_], tmp1[_], tmp2[_], pn[_]; void Calc() { int l = -2e9, r = 2e9; int cnt = Q; for (int i = 1; i \u003c= Q; ++i) p[i] = mkp(mkp(l, r), i); while (cnt) { int cntn = 0; for (int i = 1; i \u003c= tot; ++i) pt[i][0][0] = pt[i][0][1] = pt[i][1][0] = pt[i][1][1] = 1; for (int i = cnt, j = cnt; i; i = j) { int t1 = 0, t2 = 0; while (j and p[j].fi.fi == p[i].fi.fi) --j; ll l = p[i].fi.fi, r = p[i].fi.se, mid = (l + r) \u003e\u003e 1; for (int k = i; k \u003e j; --k) { int x = p[k].se; g[0] = mkp(0, 0), g[1] = mkp(-1e18, 0); SGT::Query(1, 1, n, qu[x].l, qu[x].r, mid); auto tmp = max(g[0], g[1]); if (tmp.se \u003e= qu[x].k) { if (r \u003e mid) tmp2[++t2] = mkp(mkp(mid + 1, r), x); qu[x].ans = tmp.fi + 1ll * mid * qu[x].k; } else if (l \u003c mid) tmp1[++t1] = mkp(mkp(l, mid - 1), x); } for (int k = 1; k \u003c= t2; ++k) pn[++cntn] = tmp2[k]; for (int k = 1; k \u003c= t1; ++k) pn[++cntn] = tmp1[k]; } cnt = cntn; for (int i = 1; i \u003c= cnt; ++i) p[i] = pn[cnt - i + 1]; } } int main() { cin \u003e\u003e n \u003e\u003e Q; for (int i = 1; i \u003c= n; ++i) scanf(\"%d\", \u0026a[i]); for (int i = 1; i \u003c= Q; ++i) scanf(\"%d%d%d\", \u0026qu[i].l, \u0026qu[i].r, \u0026qu[i].k), qu[i].ans = -inf; SGT::Build(1, 1, n); Calc(); for (int i = 1; i \u003c= Q; ++i) print","date":"2021-02-19","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A300iq-contest-2-hhonorable-mention/:3:0","tags":["OI","解题报告","数据结构","凸包","凸优化","闵可夫斯基和","CodeForces","300iq"],"title":"[解题报告][300iq Contest 2 H]Honorable Mention","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A300iq-contest-2-hhonorable-mention/"},{"categories":["OI","解题报告"],"content":"Statement 题面 \\(n\\) 个灯泡和 \\(n\\) 个房间匹配, 只有灯泡权值比房间权值大才能匹配, 可以将 \\(k\\) 个灯泡换成权值任意的灯泡, 求存在完美匹配的灯泡总权值的最小值. ","date":"2021-02-17","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Abzoj3728bzoj3728zarowki/:1:0","tags":["OI","解题报告","模拟费用流","bzoj"],"title":"[解题报告][bzoj3728][bzoj3728]Zarowki","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Abzoj3728bzoj3728zarowki/"},{"categories":["OI","解题报告"],"content":"Solution 首先直觉上肯定是要使灯泡和房间的权值之差越小越好. 那么可以发现一个性质, 如果我们要换灯泡, 则一定会将其权值设为某个房间的权值. 那么我们实际上只要找 \\(n - k\\) 个匹配, 然后每个匹配的代价为灯泡和房间的权值之差, 最后答案再加上所有房间的权值之和即可. 考虑怎么建图. 要注意用到 \"只有灯泡权值比房间权值大才能匹配\" 这个性质/条件. 把所有权值(包括灯泡和房间)离散化, 然后从小往大连容量为 \\(\\inf\\), 权值为 \\(w_{i + 1} - w_i\\) 的边, 然后从 \\(S\\) 连向房间对应的权值, 从灯泡对应的权值连向 \\(T\\), 那么在这张图上跑费用流即可得到答案. 发现这里所有边的方向都是一致的, 所以反边是没有用的, 所以我们只需要用堆维护一下权值相邻的房间和灯泡中权值之差的最小值, 每次把最小值的一对灯泡和房间取出来并删除. 这个显然删除操作可以用 \\(\\mathrm{set}\\) 维护, 但是时限只有 1s, 在 darkbzoj 上会 T. 而实际上把 \"删除\" 看做 \"区间合并\", 然后用并查集维护就行了. (这个并查集的细节最好先想清楚.) ","date":"2021-02-17","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Abzoj3728bzoj3728zarowki/:2:0","tags":["OI","解题报告","模拟费用流","bzoj"],"title":"[解题报告][bzoj3728][bzoj3728]Zarowki","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Abzoj3728bzoj3728zarowki/"},{"categories":["OI","解题报告"],"content":"Code #include \u003calgorithm\u003e#include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cset\u003e #define ins insert #define ers erase #define mkp make_pair #define fi first #define se second using namespace std; typedef long long ll; const int _ = 1e6 + 7; int n, K, fa[_], sz[_]; pair\u003cint, int\u003e a[_]; ll ans; priority_queue\u003cpair\u003cint, int\u003e\u003e h; int gi() { int x = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) x = (x \u003c\u003c 3) + (x \u003c\u003c 1) + c - '0', c = getchar(); return x; } int Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); } int main() { cin \u003e\u003e n \u003e\u003e K; for (int i = 1; i \u003c= n; ++i) a[i] = mkp(gi(), 1); for (int i = 1, w; i \u003c= n; ++i) w = gi(), ans += w, a[n + i] = mkp(w, 0); sort(a + 1, a + 2 * n + 1); a[0].se = 1, a[2 * n + 1].se = 0; for (int i = 1; i \u003c= 2 * n + 1; ++i) { fa[i] = i, sz[i] = 1; if (a[i].se == 0 and a[i + 1].se == 1) h.push(mkp(a[i].fi - a[i + 1].fi, i)); } for (int cnt = 1; cnt \u003c= n - K; ++cnt) { if (h.empty()) { puts(\"NIE\"); exit(0); } auto t = h.top(); h.pop(); ans += -t.fi; int x = t.se, y = Find(x + 1); assert(a[x].se == 0 and a[y].se == 1); assert(x \u003e= 1 and y \u003c= 2 * n); int tx = x - sz[x], ty = Find(y + 1); if (a[tx].se == 0 and a[ty].se == 1) h.push(mkp(a[tx].fi - a[ty].fi, tx)); fa[x] = y, sz[y] += sz[x]; fa[y] = ty, sz[ty] += sz[y]; } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-02-17","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Abzoj3728bzoj3728zarowki/:3:0","tags":["OI","解题报告","模拟费用流","bzoj"],"title":"[解题报告][bzoj3728][bzoj3728]Zarowki","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Abzoj3728bzoj3728zarowki/"},{"categories":["做题简记"],"content":"2/17 ","date":"2021-02-17","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:1:0","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":["做题简记"],"content":"[bzoj3728]Zarowki (模拟费用流) 题面 代码 时间: 16:10 ~ 17:00 标签: 模拟费用流. 难度: 中下 ","date":"2021-02-17","objectID":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/:1:1","tags":null,"title":"做题简记","uri":"/%E5%81%9A%E9%A2%98%E7%AE%80%E8%AE%B0/"},{"categories":["OI","解题报告"],"content":"Foreword 昨天晚上讲题的时候看到 \\(\\mathrm{M\\color{red}{\\_sea}}\\) 巨巨在写烷基计数, 正好我之前在搞 Burnside 引理, 于是也找来做了. 由于不清楚难度顺序, 就先开了「烷烃计数」, 想试着往之前有色图那个做法上套, 结果想了一个多小时一点思路都没有. (不过话说从这个数据范围应该就看得出做法明显不一样吧…) 后来 \\(\\mathrm{M\\color{red}{\\_sea}}\\) 给我指了条明路, 让我先去做「烷基计数」. 一语点醒梦中人, 于是就有了这篇解题报告. (三倍经验警告) ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:1:0","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"烷基计数 ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:2:0","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Statement [loj6538]烷基计数 加强版 加强版 求碳原子个数为 \\(n\\) 的烷基的同分异构体的数量. \\(n \\le 10^5\\). ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:2:1","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Solution 「烷基计数」比「烷烃计数」简单的地方在于, 「烷基计数」是有根的, 那么我们就可以考虑从根开始往下递归. 首先, 考虑怎么处理根的儿子的同构情况. 这里我们直接使用 Burnside 引理, 便把无标号的子节点变成有标号了, 然后再对每个置换算出它所对应的染色方案数量即可 (即不动点方案). 因为这里根只有 \\(3\\) 个子节点 (子节点为空的话就看做该子树的大小为 \\(0\\)), 所以总共只有 \\(3! = 6\\) 中置换, 手动把每种置换的不动点数量算出来即可. 具体来说, 设 \\(f_i\\) 表示大小为 \\(i\\) 的烷基的同分异构体的数量, 则有 \\[ f_i = \\frac{1}{6} (2[3 \\mid (i - 1)]f_{\\frac{i - 1}{3}} + 3\\sum_{j = 0}^{\\lfloor \\frac{i - 1}{2} \\rfloor} f_jf_{i - 1 - 2j} + \\sum_{j = 0}^{i - 1} \\sum_{k = 0}^{i - 1 - j} f_jf_kf_{i - 1 - j - k}) \\] 这样的话就可以得到一个 \\(O(n^3)\\) 的暴力. 下面考虑使用生成函数优化. (由于本人才疏学浅并且对生成函数的应用极其不熟练, 所以以下内容借鉴于这篇博客). (怎么想都想不到可以把指数放在 x 上) 设 \\(F(x) = \\sum_{i \\ge 0} f_ix^i\\). 那么上面的式子可以写成 \\[ F(x) = 1 + \\frac{1}{6}x[2F(x^3) + 3F(x^2)F(x) + F(x)^3] \\] (这里不要像我一样看到 \\(F(x^3)\\) 和 \\(F(x^2)\\) 这两个东西懵逼了, 实际上把它们看做两个另外的函数就可以了.) 这个式子可以分治FFT, 也可以牛顿迭代. 分治 FFT 的做法比较显然, 下面大致描述一下牛顿迭代的做法. 首先设 \\(G(F(x)) = 1 + \\frac{1}{6}x[2F(x^3) + 3F(x^2)F(x) + F(x)^3] - F(x)\\). 然后按照牛顿迭代的套路, 假设已经求出了 \\(F_0(x)\\) 满足 \\(G(F_0(X)) \\equiv 0 \\pmod{x^{\\frac{n}{2}}}\\), 现在要求 \\(F(x)\\) 满足 \\(G(F(x)) \\equiv 0 \\pmod{x^n}\\) \\[ F(x) = F_0(x) - \\frac{G(F_0(x))}{G'(F_0(x))} \\] 手动把 \\(G'(F_0(x))\\) 化一下即可. 实现的时候可以分子分母同乘一个常数, 就可以不用乘那么多逆元了. 时间复杂度为 \\(O(n\\log n)\\). 实现的时候注意清空会导致循环卷积的位置. ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:2:2","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; const int _ = (1 \u003c\u003c 20) + 7; const int mod = 998244353; int Pw(int a, int p) { int res = 1; while (p) { if (p \u0026 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; p \u003e\u003e= 1; } return res; } namespace Poly { int tot, num[_], pwrt[_], inv[_], a[_], b[_]; unsigned long long q[_]; void Init(int n) { tot = 1; while (tot \u003c n + n) tot \u003c\u003c= 1; inv[1] = 1; for (int i = 2; i \u003c= tot; ++i) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; pwrt[0] = 1, pwrt[1] = Pw(3, (mod - 1) / tot); for (int i = 2; i \u003c= tot; ++i) pwrt[i] = 1ll * pwrt[i - 1] * pwrt[1] % mod; } void NTT(int *f, bool ty, int t = tot) { for (int i = 0; i \u003c t; ++i) { num[i] = (num[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) ? t \u003e\u003e 1 : 0); q[i] = f[num[i]]; } for (int len = 2; len \u003c= t; len \u003c\u003c= 1) { int gap = len \u003e\u003e 1, d = tot / len; for (int i = 0; i \u003c t; i += len) for (int j = 0; j \u003c gap; ++j) { int tmp = q[i + j + gap] * pwrt[ty ? tot - j * d : j * d] % mod; q[i + j + gap] = q[i + j] - tmp + mod; q[i + j] = q[i + j] + tmp; } } for (int i = 0; i \u003c t; ++i) f[i] = q[i] * (ty ? inv[t] : 1) % mod; } void Mul(int *h, int *f, int *g, int t) { memcpy(a, f, t \u003c\u003c 2), memcpy(b, g, t \u003c\u003c 2), memset(h, 0, t \u003c\u003c 2); NTT(a, 0, t), NTT(b, 0, t); for (int i = 0; i \u003c t; ++i) h[i] = 1ll * a[i] * b[i] % mod; NTT(h, 1, t); } void Inv(int *h, int *f, int Len) { memset(a, 0, Len \u003c\u003c 3), memset(b, 0, Len \u003c\u003c 3); memcpy(b, f, sizeof b); memset(h, 0, Len \u003c\u003c 3); h[0] = Pw(b[0], mod - 2), a[0] = b[0], a[1] = b[1]; for (int len = 2, t = 4; len \u003c= Len; len \u003c\u003c= 1, t \u003c\u003c= 1) { NTT(a, 0, t), NTT(h, 0, t); for (int i = 0; i \u003c t; ++i) h[i] = 1ll * h[i] * (2 - 1ll * h[i] * a[i] % mod + mod) % mod; NTT(h, 1, t); memcpy(a, b, t \u003c\u003c 2), memset(h + len, 0, len \u003c\u003c 2); } } } int n, F[_], H[_], A[_], B[_], T0[_], T1[_], T2[_]; int main() { cin \u003e\u003e n; Poly::Init(2 * (n + 1)); H[0] = A[0] = B[0] = 1; for (int len = 2, t = 4; len \u003c= 2 * (n + 1); len \u003c\u003c= 1, t \u003c\u003c= 1) { memset(T0 + len, 0, len \u003c\u003c 2); for (int i = 0; i \u003c len; ++i) T0[i] = 2ll * A[i] % mod; Poly::Mul(T1, B, H, t); for (int i = 0; i \u003c len; ++i) T0[i] = (T0[i] + 3ll * T1[i] % mod) % mod; Poly::Mul(T2, H, H, t), Poly::Mul(T1, T2, H, t); for (int i = len - 1; i; --i) T0[i] = (T0[i - 1] + T1[i - 1]) % mod; T0[0] = 6; for (int i = 0; i \u003c len / 2; ++i) T0[i] = (T0[i] - 6ll * H[i] % mod + mod) % mod; for (int i = len - 1; i; --i) T1[i] = 3ll * (B[i - 1] + T2[i - 1]) % mod; T1[0] = mod - 6; Poly::Inv(T1, T1, len); memset(T1 + len, 0, len \u003c\u003c 2); Poly::Mul(T0, T0, T1, t); for (int i = 0; i \u003c len; ++i) H[i] = (H[i] - T0[i] + mod) % mod, A[i] = B[i] = 0; for (int i = 0; i \u003c len * 2 / 3; ++i) A[i * 3] = H[i]; for (int i = 0; i \u003c len; ++i) B[i * 2] = H[i]; } cout \u003c\u003c H[n] \u003c\u003c endl; return 0; } ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:2:3","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"烯烃计数 ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:3:0","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"statement [luoguP6597]烯烃计数 求出碳原子数量为 \\(2 \\sim n\\) 的 单烯烃 的同分异构体数量. \\( n \\le 10^5 \\). ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:3:1","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Solution 容易想到把碳碳双键看做根, 而碳碳双键两边的碳原子所连出去的东西其实就是若干个烷基, 所以先按照上面的方法算出烷基个数. 然后碳碳双键两边的碳原子只有两个儿子, 那么也与上面类似, 对大小为 \\(2\\) 的置换讨论一下, 列出式子, 然后生成函数乘一下即可. (需要注意这里 \\(x^0\\) 的系数要为 \\(0\\), 因为碳碳双键两边必须要接碳原子.) 然后对于这个碳碳双键, 可以把它看做一个点, 然后也是用 Burnside 引理按照上面的做法弄一下就好了. 时间复杂度为 \\(O(n \\log n)\\). (其实和烷基计数没什么区别, 不过可以用来水水题量.) ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:3:2","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; const int _ = (1 \u003c\u003c 20) + 7; const int mod = 998244353; int Pw(int a, int p) { int res = 1; while (p) { if (p \u0026 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; p \u003e\u003e= 1; } return res; } namespace Poly { int tot, num[_], pwrt[_], inv[_], a[_], b[_]; unsigned long long q[_]; void Init(int n) { tot = 1; while (tot \u003c n + n) tot \u003c\u003c= 1; inv[1] = 1; for (int i = 2; i \u003c= tot; ++i) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; pwrt[0] = 1, pwrt[1] = Pw(3, (mod - 1) / tot); for (int i = 2; i \u003c= tot; ++i) pwrt[i] = 1ll * pwrt[i - 1] * pwrt[1] % mod; } void NTT(int *f, bool ty, int t = tot) { for (int i = 0; i \u003c t; ++i) { num[i] = (num[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) ? t \u003e\u003e 1 : 0); q[i] = f[num[i]]; } for (int len = 2; len \u003c= t; len \u003c\u003c= 1) { int gap = len \u003e\u003e 1, d = tot / len; for (int i = 0; i \u003c t; i += len) for (int j = 0; j \u003c gap; ++j) { int tmp = q[i + j + gap] * pwrt[ty ? tot - j * d : j * d] % mod; q[i + j + gap] = q[i + j] - tmp + mod; q[i + j] = q[i + j] + tmp; } } for (int i = 0; i \u003c t; ++i) f[i] = q[i] * (ty ? inv[t] : 1) % mod; } void Mul(int *h, int *f, int *g, int t) { memcpy(a, f, t \u003c\u003c 2), memcpy(b, g, t \u003c\u003c 2), memset(h, 0, t \u003c\u003c 2); NTT(a, 0, t), NTT(b, 0, t); for (int i = 0; i \u003c t; ++i) h[i] = 1ll * a[i] * b[i] % mod; NTT(h, 1, t); } void Inv(int *h, int *f, int Len) { memset(a, 0, Len \u003c\u003c 3), memset(b, 0, Len \u003c\u003c 3); memcpy(b, f, sizeof b); memset(h, 0, Len \u003c\u003c 3); h[0] = Pw(b[0], mod - 2), a[0] = b[0], a[1] = b[1]; for (int len = 2, t = 4; len \u003c= Len; len \u003c\u003c= 1, t \u003c\u003c= 1) { NTT(a, 0, t), NTT(h, 0, t); for (int i = 0; i \u003c t; ++i) h[i] = 1ll * h[i] * (2 - 1ll * h[i] * a[i] % mod + mod) % mod; NTT(h, 1, t); memcpy(a, b, t \u003c\u003c 2), memset(h + len, 0, len \u003c\u003c 2); } } } int n, F[_], G[_], H[_], A[_], B[_], T0[_], T1[_], T2[_], inv2 = 499122177; int main() { cin \u003e\u003e n; Poly::Init(2 * (n + 1)); H[0] = A[0] = B[0] = 1; int len, t; for (len = 2, t = 4; len \u003c= 2 * (n + 1); len \u003c\u003c= 1, t \u003c\u003c= 1) { memset(T0 + len, 0, len \u003c\u003c 2); for (int i = 0; i \u003c len; ++i) T0[i] = 2ll * A[i] % mod; Poly::Mul(T1, B, H, t); for (int i = 0; i \u003c len; ++i) T0[i] = (T0[i] + 3ll * T1[i] % mod) % mod; Poly::Mul(T2, H, H, t), Poly::Mul(T1, T2, H, t); for (int i = len - 1; i; --i) T0[i] = (T0[i - 1] + T1[i - 1]) % mod; T0[0] = 6; for (int i = 0; i \u003c len / 2; ++i) T0[i] = (T0[i] - 6ll * H[i] % mod + mod) % mod; for (int i = len - 1; i; --i) T1[i] = 3ll * (B[i - 1] + T2[i - 1]) % mod; T1[0] = mod - 6; Poly::Inv(T1, T1, len); memset(T1 + len, 0, len \u003c\u003c 2); Poly::Mul(T0, T0, T1, t); for (int i = 0; i \u003c len; ++i) H[i] = (H[i] - T0[i] + mod) % mod, A[i] = B[i] = 0; for (int i = 0; i \u003c len * 2 / 3; ++i) A[i * 3] = H[i]; for (int i = 0; i \u003c len; ++i) B[i * 2] = H[i]; } len \u003e\u003e= 1, t \u003e\u003e= 1; Poly::Mul(G, H, H, t); memset(G + len, 0, len \u003c\u003c 2); for (int i = len - 1; i; --i) G[i] = 1ll * inv2 * (B[i - 1] + G[i - 1]) % mod; G[0] = 0; memset(B, 0, len \u003c\u003c 2); for (int i = 0; i \u003c len; ++i) B[i * 2] = G[i]; Poly::Mul(F, G, G, t); for (int i = 0; i \u003c len; ++i) F[i] = 1ll * inv2 * (B[i] + F[i]) % mod; for (int i = 2; i \u003c= n; ++i) printf(\"%d\\n\", F[i]); return 0; } ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:3:3","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"烷烃计数 ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:4:0","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Statement luoguP6598]烷烃计数 求出碳原子数量为 \\(n\\) 的烷烃的同分异构体数量. \\(n \\le 10^5\\). ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:4:1","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Solution. 在经历了「烷基计数」和「烯烃计数」的洗礼后, 我突然领悟了 \\(\\mathrm{M\\color{red}{\\_sea}}\\) 看似漫不经心实际别有深意地 说出的一个词: 「重心」. 现在, 烷烃计数难搞的地方只在于它没有根, 那么我们要是能对一个烷烃找到一个唯一的根, 那么问题就迎刃而解了. 而「重心」就是一个经典的选择. 对于 \\(n\\) 为奇数的情况, 由于重心只会有一个, 所以直接把重心作为根即可. 具体来说, 就是先求出烷基个数, 在最后合并的时候, 根节点有 \\(4\\) 个儿子, 并且每一个子树的大小都小于 \\(\\lceil \\frac{n}{2} \\rceil \\). 那么我们对 \\(4! = 24\\) 个置换讨论一下即可. 当然可能会有点麻烦. 对于 \\(n\\) 为偶数的情况, 若重心有一个子树的大小为 \\( \\frac{n}{2} \\), 则这时会有两个重心, 这个烷烃就会被统计两次. (可以画个图理解.) 所以我们限制每个子树大小都小于 \\( \\frac{n}{2} \\), 然后按上面 \\(n\\) 为奇数的情况统计. 而对于有两个重心的情况, 我们可以把两个重心之间那条边看做一个点, 然后对 \\(2! = 2\\) 个置换讨论一下即可. (跟上面烯烃计数的情况差不多.) 复杂度为 \\(O(n \\log n)\\). ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:4:2","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; const int _ = (1 \u003c\u003c 20) + 7; const int mod = 998244353; int Pw(int a, int p) { int res = 1; while (p) { if (p \u0026 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; p \u003e\u003e= 1; } return res; } namespace Poly { int tot, num[_], pwrt[_], inv[_], a[_], b[_]; unsigned long long q[_]; void Init(int n) { tot = 1; while (tot \u003c n + n) tot \u003c\u003c= 1; inv[1] = 1; for (int i = 2; i \u003c= tot; ++i) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; pwrt[0] = 1, pwrt[1] = Pw(3, (mod - 1) / tot); for (int i = 2; i \u003c= tot; ++i) pwrt[i] = 1ll * pwrt[i - 1] * pwrt[1] % mod; } void NTT(int *f, bool ty, int t = tot) { for (int i = 0; i \u003c t; ++i) { num[i] = (num[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) ? t \u003e\u003e 1 : 0); q[i] = f[num[i]]; } for (int len = 2; len \u003c= t; len \u003c\u003c= 1) { int gap = len \u003e\u003e 1, d = tot / len; for (int i = 0; i \u003c t; i += len) for (int j = 0; j \u003c gap; ++j) { int tmp = q[i + j + gap] * pwrt[ty ? tot - j * d : j * d] % mod; q[i + j + gap] = q[i + j] - tmp + mod; q[i + j] = q[i + j] + tmp; } } for (int i = 0; i \u003c t; ++i) f[i] = q[i] * (ty ? inv[t] : 1) % mod; } void Mul(int *h, int *f, int *g, int t = tot) { memcpy(a, f, t \u003c\u003c 2), memcpy(b, g, t \u003c\u003c 2), memset(h, 0, t \u003c\u003c 2); NTT(a, 0, t), NTT(b, 0, t); for (int i = 0; i \u003c t; ++i) h[i] = 1ll * a[i] * b[i] % mod; NTT(h, 1, t); } void Inv(int *h, int *f, int Len) { memset(a, 0, Len \u003c\u003c 3), memset(b, 0, Len \u003c\u003c 3); memcpy(b, f, sizeof b); memset(h, 0, Len \u003c\u003c 3); h[0] = Pw(b[0], mod - 2), a[0] = b[0], a[1] = b[1]; for (int len = 2, t = 4; len \u003c= Len; len \u003c\u003c= 1, t \u003c\u003c= 1) { NTT(a, 0, t), NTT(h, 0, t); for (int i = 0; i \u003c t; ++i) h[i] = 1ll * h[i] * (2 - 1ll * h[i] * a[i] % mod + mod) % mod; NTT(h, 1, t); memcpy(a, b, t \u003c\u003c 2), memset(h + len, 0, len \u003c\u003c 2); } } } int n, m, F[_], G[_], H[_], A[_], B[_], C[_], T0[_], T1[_], T2[_], inv24 = 291154603; int main() { cin \u003e\u003e n; m = (n \u0026 1) ? n / 2 + 1 : n / 2; Poly::Init(2 * (n + 1)); H[0] = A[0] = B[0] = 1; int len, t; for (len = 2, t = 4; len \u003c= 2 * (m + 1); len \u003c\u003c= 1, t \u003c\u003c= 1) { memset(T0 + len, 0, len \u003c\u003c 2); for (int i = 0; i \u003c len; ++i) T0[i] = 2ll * A[i] % mod; Poly::Mul(T1, B, H, t); for (int i = 0; i \u003c len; ++i) T0[i] = (T0[i] + 3ll * T1[i] % mod) % mod; Poly::Mul(T2, H, H, t), Poly::Mul(T1, T2, H, t); for (int i = len - 1; i; --i) T0[i] = (T0[i - 1] + T1[i - 1]) % mod; T0[0] = 6; for (int i = 0; i \u003c len / 2; ++i) T0[i] = (T0[i] - 6ll * H[i] % mod + mod) % mod; for (int i = len - 1; i; --i) T1[i] = 3ll * (B[i - 1] + T2[i - 1]) % mod; T1[0] = mod - 6; Poly::Inv(T1, T1, len); memset(T1 + len, 0, len \u003c\u003c 2); Poly::Mul(T0, T0, T1, t); for (int i = 0; i \u003c len; ++i) H[i] = (H[i] - T0[i] + mod) % mod, A[i] = B[i] = 0; for (int i = 0; i \u003c len * 2 / 3; ++i) A[i * 3] = H[i]; for (int i = 0; i \u003c len; ++i) B[i * 2] = H[i]; } if (t \u003e Poly::tot) t \u003e\u003e= 1, len \u003e\u003e= 1; memset(T0, 0, sizeof T0), memset(A, 0, sizeof A), memset(B, 0, sizeof B), memset(C, 0, sizeof C); memcpy(T0, H, m \u003c\u003c 2); for (int i = 0; i \u003c len / 2; ++i) A[i * 4] = T0[i]; for (int i = 0; i \u003c len * 2 / 3; ++i) B[i * 3] = T0[i]; for (int i = 0; i \u003c len; ++i) C[i * 2] = T0[i]; memset(A + len, 0, len \u003c\u003c 2), memset(B + len, 0, len \u003c\u003c 2), memset(C + len, 0, len \u003c\u003c 2); for (int i = 0; i \u003c len; ++i) F[i] = 6ll * A[i] % mod; Poly::Mul(T1, B, T0, t); for (int i = 0; i \u003c len; ++i) F[i] = (F[i] + 8ll * T1[i] % mod) % mod; Poly::Mul(T1, C, C, t); for (int i = 0; i \u003c len; ++i) F[i] = (F[i] + 3ll * T1[i] % mod) % mod; Poly::Mul(T1, T0, T0, t), memset(T1 + len, 0, len \u003c\u003c 2), Poly::Mul(T1, T1, C); for (int i = 0; i \u003c len; ++i) F[i] = (F[i] + 6ll * T1[i] % mod) % mod; Poly::Mul(T1, T0, T0, t), memset(T1 + len, 0, len \u003c\u003c 2), Poly::Mul(T1, T1, T1, t); for (int i = 0; i \u003c len; ++i) F[i] = (F[i] + T1[i]) % mod; for (int i = len - 1; i; --i) F[i] = 1ll * inv24 * F[i - 1] % mod; F[0] = 1; if (n \u0026 1) printf(\"%d\\n\", F[n]); else { int ans = 1ll * (H[n / 2] + 1ll * H[n / 2] * H[n / 2] % mod) * Pw(2, mod - 2) % mod; printf(\"%d\\n\", (ans + F[n]) % mod); } return 0; } ","date":"2021-02-16","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/:4:3","tags":["解题报告","Burnside引理","数学","计数"],"title":"[解题报告]烷基计数\u0026烯烃计数\u0026烷烃计数","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0%E7%83%AF%E7%83%83%E8%AE%A1%E6%95%B0%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0/"},{"categories":["OI","学习笔记"],"content":"一些不太清楚的问题 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:1:0","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"一 在分治FFT求 \\( \\Pi_{j} (1 - a_jy) \\) 的时候，由于递归到底的时候要为 \\( 1 - a_jy \\) 留两个位置，所以最终会导致求出来的数组是 tot 级别的，而实际上 \\( \\Pi_{j} (1 - a_jy) \\) 是 \\( \\frac{tot}{2} \\) 级别的，造成了浪费，而且感觉不太优美 答：看了一份题解的代码，貌似也没有对这方面的处理，那也就只能这样写了。 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:1:1","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"二 鸡贼课件里说所谓 “转置原理” 就是 \\( f(x) \\times g(x) \\cdot h(x) \\Leftrightarrow g(x) \\cdot h(x) \\times f(\\frac{1}{x}) \\) ，但这个下标问题有点迷，还得推一下 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:1:2","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"gzy课件 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:2:0","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"一 关于鸡贼写的那个\\( f(x) \\times g(x) \\cdot h(x) \\Leftrightarrow g(x) \\cdot h(x) \\times f(\\frac{1}{x}) \\)，如果直接按这种形式写的话貌似会扯到循环卷积，就比较烦。 目前我只知道如果把 \\( f(\\frac{1}{x}) \\) 直接看做 \\(f_r(x)\\) （对前 \\( 0 \\sim n - 1 \\) 项翻转）的话，可以把点积转化为卷积的 \\( x^{n-1} \\) 项系数，不知道其他用法会不会对这个翻转的要求不一样。 upd: 推了一波式子，并实验了一波，得到结论其实是 \\( A(x)B(x) \\cdot C(x) = Ar(x) \\cdot B(x)Cr(x) = Br(x) \\cdot A(x)Cr(x) = A(x) \\cdot (B(x)Cr(x))r \\) 注意 ： 不是 \\(Ar(x) \\cdot Br(x)C(x)\\)，究其原因在于进行减法卷积时，若将两个多项式互换，最终得到的结果会不一样。 但对于 \\(A(x)B(x) \\cdot C(x)D(x)\\) 这种形式除了先把 \\(C,D\\) 卷起来之外暂时没想到什么更好的方法，因为要扯到减法卷积。 挖个坑 点积本质上就是减法卷积的0次项系数，所以推一下式子可以得到加法卷积和减法卷积的转换律，不过好像想不到什么应用，感觉有点鸡肋？ 减法卷积：设 \\(A(x) \\circ B(x) = \\sum_{i = 0}^{n-1}x^i\\sum_{j = i}^{n-1} a_jb_{j-i}\\)，则 \\(A(x) \\circ B(x) = (Ar(x)B(x))r\\) （猜的，待验证） ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:2:1","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"二 突然感觉鸡贼写的有点nb，居然能把转置抽象成一个纯多项式的东西？ 如果能把多项式操作和矩阵变换联系起来，估计就比较好理解了。 点积好像还行，但卷积怎么转化为矩阵？ ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:2:2","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"转置原理的简单介绍 笔记 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:3:0","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"线性算法 一个 \\( n \\times n \\) 常数矩阵 \\(A\\) 左乘一个 \\( n \\times 1 \\) 的变量向量 \\( a\\)，得到 \\( b \\) 的算法 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:3:1","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"转置 对于线性算法 \\( b = Aa \\)，称 \\( b' = A^Ta \\) 为它的转置算法。（ \\(A^T\\) 表示矩阵 \\(A\\) 的转置，就是沿主对角线翻转） 其实我感觉把向量换成矩阵也成立 定理： 设 \\( A = E_1 E_2 E_3 \\cdots E_k \\) 则 \\( A^T = E_k^T E_{k-1}^T E_{k-2}^T \\cdots E_1^T \\) 其中 \\(E\\) 为初等矩阵 然后如果你把矩乘换回普通操作（就是普通 C++ 语句），就相当于把所有操作反着做一遍，什么参数传入改为返回，函数调用顺序反过来…… 有种看 信条 的感觉 5-2 复合 简单函数 4 没看懂 一元函数的复合可以用复合的结合律简化运算 但二元函数怎么办？ 二元函数 \\( F(x,y) \\) 左乘一个向量 \\( b(y) \\)，\\( y^i \\) 没有什么实际意义，只是相当于建立了一个对应关系，从而得到每一个 \\( x^i \\) 的系数。而复合函数 \\( q'(sp(y)) \\) 也是建立了一个对应关系，如果我们把复合函数的对应关系一层层扒下来，那么就可以简化运算。 设我们现在要求 \\( f(p(x)q(y)) \\cdot b(y) \\)，然后 \\( q(y) \\) 能写成 \\(q'(sp(y))\\) 的形式，其中 \\( sp(y) \\) 是一个简单函数。 我们考虑把 \\(b(y)\\) 换个基，变成 \\(b'(sp(y))\\)，然后就相当于把 \\(sp(y)\\) 扒出来了。 考虑如何求 \\(b'\\)。 设 \\(sp^{-1}(y)\\) 为 \\(sp(y)\\) 的复合逆，设 \\(t = sp(y)\\)， 则 \\(y = sp^{-1}(sp(y)) = sp^{-1}(t) \\)， 那么把 \\(y = sp^{-1}(t)\\) 带入 \\(b(y)\\) 就可以得到 \\(b(y) = b(sp^{-1}(t))\\)，所以 \\(b'(sp(y)) = b'(t) = b(sp^{-1}(t)) \\)，也即 \\(b' = b \\circ sp^{-1}\\)。 所以原式就可以变为 \\(f(p(x)q'(t)) \\cdot b'(t) \\)，然后再把 \\(q'(t)\\) 一层一层按照上面的过程拆下去，直到得到一个 \\(q'_{final}(z) = z\\)， 那么原式为 \\(f(p(x)q'_{final}(z)) \\cdot b''(z) \\)， 展开后就是 \\( \\begin{aligned} f(p(x)q'_{final}(z)) \\cdot b''(z) \u0026= (\\sum_{i} f_i p(x)^i z^i) \\cdot (\\sum_{i}b''_{i} z^i) \\\\ \u0026= \\sum_{i} f_i b''_{i}p(x)^i z^i \\\\ \\end{aligned} \\) 所以可以先把 \\(f\\) 和 \\(b''\\) 点积起来，设 \\(f'(t) = f(t) \\cdot b(t) \\)，之后的操作就是 \\( f' \\circ p \\)，然后由于 \\(p\\) 又是由若干个简单函数复合而成，所以可以根据复合的结合律来一层层复合。 回到更普通的形式，即 \\(u(x)v(y)f(p(x)q(y)) \\cdot b(y) \\)， 对于 \\(v(y)\\)，我们使用 \\(A(x)B(x) \\cdot C(x) = A(x) \\cdot (B(x)Cr(x))r\\) 的技巧，先把 \\(v(y)\\) 挪到右边，然后就变为了 \\(u(x)v(y)f(p(x)q(y)) \\cdot b'(y) \\)， 接着再按照上面的步骤，最后得到 \\(u(x)(\\sum_{i} f_i b''_{i}p(x)^i z^i)\\)，那么就先把后面那项求出来，然后再卷一次就OK了 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:3:2","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"DFT的转置 尝试用转置方法写了发DFT，为啥转置后跑得飞快啊？？？ UOJ上普通写法总时间2000ms左右，转置写法只要不到700ms。。。 感觉运算量没差吧？？？？？ 但为啥洛谷上又没啥差别。。。。 结果只是刚刚UOJ抽风了。。。。 由于转置方法是分治算完后二进制翻转，而原方法是分治算之前二进制翻转，所以如果你DFT用转置方法，IDFT用原方法，就可以少两个二进制翻转的过程，稍微能快那么一丢丢。 ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:3:3","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","学习笔记"],"content":"xgzc的课件 那个 “复合矩阵” 看得我一脸懵逼，没太懂 \\(COM(F)_{i,j} = [x^j]F(x^i)\\) 是啥意思 然后从 \\( A(x,y) = \\sum_{i=0}^{n-1}g(x)^i f_i h(y)^i \\) 到 \\( A = COM^T(g)I(f)COM(h) \\) 也没看懂 没事了, 原来是他把 \\(F(x)^i\\) 写成了 \\(F(x^i)\\) ","date":"2021-02-08","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/:4:0","tags":["学习笔记","OI","转置原理","线性代数","草稿"],"title":"[学习笔记]转置原理 (Draft)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 一个点数为 \\(n\\) 的环 (项链), 每个点可以被染成黑色或白色. 染色要求为: 恰好有 \\(m\\) 个点被染为黑色, 且不存在长度 \\(\u003ek\\) 的黑色连续串. 考虑旋转同构, 求本质不同的的染色方案数. \\( m \\le n \\le 10^5, k \\le 10^5\\). ","date":"2021-02-08","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/:1:0","tags":["解题报告","luogu","Burnside引理","数学","计数","容斥"],"title":"[解题报告][luogu4916]魔力环","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/"},{"categories":["OI","解题报告"],"content":"Solution 这里旋转就相当于置换, 本质不同的的染色方案就相当于轨道数. 那么使用 Burnside 引理, 把轨道数转化为置换的不动点数量. 这里总共有 \\(n\\) 个置换, 每个置换都形如 \\[ \\begin{Bmatrix} 1 \u0026 2 \u0026 3 \u0026 \\cdots \u0026 n - i + 1 \u0026 n - i \u0026 \\cdots \u0026 n - 1 \u0026 n \\\\ i \u0026 i + 1 \u0026 i + 2 \u0026 \\cdots \u0026 n \u0026 1 \u0026 \\cdots \u0026 i - 2 \u0026 i - 1 \\end{Bmatrix} \\] 那么第 \\(i\\) 个置换的每个循环的长度为 \\( \\mathrm{lgt} = \\frac{lcm(i, n)}{i} = \\frac{n}{\\gcd(i, n)} \\), 循环的数量为 \\( \\mathrm{num} = \\gcd(i, n) \\). 所以 \\(n\\) 就会被分成 \\(\\mathrm{lgt}\\) 段由 \\(\\mathrm{num}\\) 个属于不同循环的点组成的区间 (是的这里没打错). 那么对这个 \\(n\\) 元环的染色就相当于对这个 \\(\\mathrm{num}\\) 元环的染色. (因为每个循环中的颜色都必须相同.) 那么我们设 \\( g(i, j) \\) 为给 \\(i\\) 元环染上 \\(m\\) 个黑点的合法方案数 (不考虑循环同构). 那么我们要求的就是 (这里我们默认 \\( \\frac{n}{\\gcd(i, n)} \\mid m \\).) \\[ \\frac{1}{n} \\sum_{i = 1}^n g(\\gcd(i, n), \\frac{m}{n / \\gcd(i, n)}) \\] 改为枚举 \\(\\gcd\\) (默认 \\( d \\mid n \\)) \\[ \\begin{aligned} \\frac{1}{n} \\sum_{i = 1}^n g(\\gcd(i, n), \\frac{m}{n / \\gcd(i, n)}) \u0026= \\frac{1}{n} \\sum_{d = 1}^n g(d, \\frac{m}{n / d}) \\sum_{i = 1}^{\\frac{n}{d}} [\\gcd(\\frac{n}{d}, i) = 1] \\\\ \u0026= \\frac{1}{n} \\sum_{d = 1}^n g(d, \\frac{m}{n / d}) \\varphi(\\frac{n}{d}) \\end{aligned} \\] 那么现在考虑怎么求 \\(g(d, \\frac{m}{n / d})\\). 环不好弄, 那么我们枚举最后一段黑色连续段和第一段黑色连续段的长度之和, 断环为链. 然后因为黑点和白点的数量是固定的, 所以我们可以把黑色连续段看做把若干个黑点放在白点之间. 然后每段黑色连续段长度不超过 \\(k\\) 的方案可以用容斥算出来. 形式化地说, 设 \\( h(n, c) \\) 为将 \\(c\\) 个黑点放进 \\(n\\) 个空位中的方案. 则有 \\[ g(d, \\frac{m}{n / d}) = \\sum_{i = 0}^k (i + 1) h(d - \\frac{m}{n / d} - 1, \\frac{m}{n / d} - i) \\] (乘上 \\((i + 1)\\) 是因为要算最后一段和第一段分别放了多少个黑点.) \\[ h(n, c) = \\sum_{i = 0}^{\\lfloor\\frac{c}{k + 1}\\rfloor} (-1)^i \\binom{n}{i} \\binom{c - i(k + 1) + n - 1}{n - 1} \\] (最后一个组合数是用 插板法 + 可重组合 计算把 \\(c - i(k + 1)\\) 个黑点放进 \\(n\\) 个空位的方案.) 这样每次计算 \\(g(d, \\frac{m}{n / d})\\) 的时间复杂度为 \\( O(k \\lfloor\\frac{\\frac{m}{n / d}}{k + 1}\\rfloor) = O(d)\\), 所以总时间复杂度为 \\( O(\\sigma(n)) \\). ","date":"2021-02-08","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/:2:0","tags":["解题报告","luogu","Burnside引理","数学","计数","容斥"],"title":"[解题报告][luogu4916]魔力环","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ciostream\u003e using namespace std; const int _ = 2e5 + 7; const int mod = 998244353; int n, m, K, pri[_], phi[_], v[_], cnt, fac[_], ifac[_], inv[_]; void Init() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e K; if (m == n) { puts(\"0\"); exit(0); } phi[1] = 1; for (int i = 2; i \u003c= n; ++i) { if (!v[i]) pri[++cnt] = i, v[i] = i, phi[i] = i - 1; for (int j = 1; j \u003c= cnt and pri[j] \u003c= v[i] and i * pri[j] \u003c= n; ++j) { v[i * pri[j]] = pri[j]; phi[i * pri[j]] = i % pri[j] ? phi[i] * phi[pri[j]] : phi[i] * pri[j]; } } fac[0] = ifac[0] = inv[1] = 1; for (int i = 1; i \u003c= 2 * n; ++i) { fac[i] = 1ll * fac[i - 1] * i % mod; if (i != 1) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod; } } int C(int n, int m) { return n \u003c 0 or m \u003c 0 ? 0 : 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; } int F(int sum, int num) { if (num == 0) return sum == 0; int res = 0; for (int i = 0; i \u003c= min(sum / (K + 1), num); ++i) { int tmp = 1ll * C(num, i) * C(sum - (K + 1) * i + num - 1, num - 1) % mod; res = (res + ((i \u0026 1) ? mod - tmp : tmp)) % mod; } return res; } int main() { Init(); int ans = 0; for (int d = 1; d \u003c= n; ++d) if (!(n % d) and !(m % (n / d))) { int t = m / (n / d), res = 0; for (int i = 0; i \u003c= min(t, K); ++i) res = (res + 1ll * (i + 1) * F(t - i, d - t - 1) % mod) % mod; ans = (ans + 1ll * res * phi[n / d] % mod) % mod; } cout \u003c\u003c 1ll * ans * inv[n] % mod \u003c\u003c endl; return 0; } ","date":"2021-02-08","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/:3:0","tags":["解题报告","luogu","Burnside引理","数学","计数","容斥"],"title":"[解题报告][luogu4916]魔力环","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/"},{"categories":["OI","解题报告"],"content":"Reference 题解 by yybyyb ","date":"2021-02-08","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/:4:0","tags":["解题报告","luogu","Burnside引理","数学","计数","容斥"],"title":"[解题报告][luogu4916]魔力环","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu4916%E9%AD%94%E5%8A%9B%E7%8E%AF/"},{"categories":["OI","解题报告"],"content":"Statement 传送门 一张 \\(n\\) 个点的无向完全图, 每条边可以染上 \\(m\\) 种颜色之一, 求 \\(n!\\) 种点置换下本质不同的染色方案. \\(n \\le 53 \\). ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ashoi2006%E6%9C%89%E8%89%B2%E5%9B%BE/:1:0","tags":["解题报告","省选","SHOI","SHOI2006","Burnside引理","Pólya计数定理","数学","计数"],"title":"[解题报告][SHOI2006]有色图","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ashoi2006%E6%9C%89%E8%89%B2%E5%9B%BE/"},{"categories":["OI","解题报告"],"content":"Solution 看到置换 + 染色, 先考虑一波 Burnside 引理. (实际上这里用的是 Pólya 计数定理.) 需要注意的是这里是对 边 染色, 对 点 置换, 所以我们要先把 点置换 转成 边置换 后才能用 Burnside 引理做. 我们把一个点置换用循环的形式表示, 即 \\( q_1q_2q_3 \\cdots q_k \\), 其中 \\( q_i \\) 表示该置换的第 \\( i \\) 个循环的大小. 我们这里把 \\(q_i\\) 排序后的结果称为该点置换的 循环表示, 那么可以推导出符合一个循环表示的点置换的数量为 \\[ \\mathrm{tms} = n! \\prod_{i = 1}^k \\frac{1}{q_i} \\prod_{i = 1}^n \\frac{1}{\\#_i} \\] 其中 \\(n!\\) 是为了 \\(n\\) 个点分配到每个循环; \\(\\prod_{i = 1}^k \\frac{1}{q_i}\\) 是因为循环是个圆排列, 所以要除以 \\(q_i\\); \\(\\#_i\\) 表示该置换中大小为 \\(i\\) 的循环的数量, 因为相同的循环之间应该是无序的, 否则会算重. 接下来考虑怎么算边置换. 首先有一个显然的结论, 「循环表示相同的点置换所对应的边置换相同」. 那么我们只需要考虑对于一个循环表示, 它对应的点置换所对应的边置换有多少个循环. (有点绕.) 首先考虑端点在同一个点循环内的边. 容易发现, 在同一个点循环内, 端点距离相同的边构成了一个边循环, 而一个大小为 \\(q_i\\) 的点循环内有 \\( \\lfloor \\frac{q_i}{2} \\rfloor \\) 种端点距离. 所以一个大小为 \\(q_i\\) 点循环可以贡献 \\( \\lfloor \\frac{q_i}{2} \\rfloor \\) 个边循环. 再考虑端点在两个不同点循环内的边. 两个大小分别为 \\(q_1, q_2\\) 的点循环之间有 \\(q_1q_2\\) 条边, 而一个边循环的长度为 \\( lcm(q_1, q_2) = \\frac{q_1q_2}{\\gcd(q_1, q_2)} \\) (画张图可以便于理解), 所以这两个点循环可以贡献 \\( \\gcd(q_1, q_2) \\) 个边循环. 所以一个循环表示为 \\(q_1q_2 \\cdots q_k\\) 的点循环所对应的边置换的循环数量为 \\[ \\mathrm{num} = \\sum_{i = 1}^k \\lfloor \\frac{q_i}{2} \\rfloor + \\sum_{i = 1}^k \\sum_{j = i + 1}^k \\gcd(q_i, q_j) \\] 所以一个循环表示所对应的不动点数量就是 \\[ \\mathrm{tms} \\cdot m^{\\mathrm{num}} \\] 所以只要枚举序列 \\( \\{ q \\} \\) 然后统计它的 \\(\\mathrm{tms}\\) 和 \\(\\mathrm{num}\\) 即可. 设 \\(Q(n)\\) 为点数为 \\(n\\) 的循环表示数量, 即为 \\(n\\) 的划分数. 暴搜一下, 发现 \\(Q(53) = 329931\\). 所以时间复杂度为 \\( O(Q(n)n^2) \\), 然而跑不满 (因为枚举两个点循环那地方不一定是 \\(n^2\\)). 所以是 O(能过). ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ashoi2006%E6%9C%89%E8%89%B2%E5%9B%BE/:2:0","tags":["解题报告","省选","SHOI","SHOI2006","Burnside引理","Pólya计数定理","数学","计数"],"title":"[解题报告][SHOI2006]有色图","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ashoi2006%E6%9C%89%E8%89%B2%E5%9B%BE/"},{"categories":["OI","解题报告"],"content":"Code #include \u003ccstdio\u003e#include \u003ciostream\u003e using namespace std; const int _ = 53 + 7; const int __ = 3e3 + 7; int n, m, mod, fac[_], ifac[_], inv[_], pw[__], ans, p[_], gcd[_][_], tot; int Gcd(int a, int b) { return b ? Gcd(b, a % b) : a; } void Dfs(int k, int las, int cnt) { if (k == n) { int tms = fac[n], num = 0; for (int i = 1; i \u003c cnt; ++i) { tms = 1ll * tms * inv[p[i]] % mod; num += p[i] / 2; for (int j = i + 1; j \u003c cnt; ++j) num += gcd[p[i]][p[j]]; } for (int i = 1, j = 1; i \u003c cnt; i = j) { while (j \u003c cnt and p[j] == p[i]) ++j; tms = 1ll * tms * ifac[j - i] % mod; } ans = (ans + 1ll * tms * pw[num] % mod) % mod; tot = (tot + tms) % mod; return; } for (int i = 1; i \u003c= min(las, n - k); ++i) p[cnt] = i, Dfs(k + i, i, cnt + 1); } int main() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e mod; pw[0] = fac[0] = ifac[0] = inv[1] = 1; for (int i = 1; i \u003c= n; ++i) { if (i != 1) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; fac[i] = 1ll * fac[i - 1] * i % mod; ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod; } for (int i = 1; i \u003c= n * n; ++i) pw[i] = 1ll * pw[i - 1] * m % mod; for (int i = 1; i \u003c= n; ++i) for (int j = 1; j \u003c= n; ++j) gcd[i][j] = Gcd(i, j); Dfs(0, n, 1); cout \u003c\u003c 1ll * ans * ifac[n] % mod \u003c\u003c endl; cerr \u003c\u003c \"tot: \" \u003c\u003c tot \u003c\u003c ' ' \u003c\u003c fac[n] \u003c\u003c endl; return 0; } ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ashoi2006%E6%9C%89%E8%89%B2%E5%9B%BE/:3:0","tags":["解题报告","省选","SHOI","SHOI2006","Burnside引理","Pólya计数定理","数学","计数"],"title":"[解题报告][SHOI2006]有色图","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Ashoi2006%E6%9C%89%E8%89%B2%E5%9B%BE/"},{"categories":null,"content":"Statement 传送门 \\( n \\) 个点, $m$ 种颜色, 颜色为 $i$ 的点有 $a_i$ 个. 求这 $n$ 个点构成的本质不同无标号有序基环树个数. (有序: 子树有序) 两棵基环树本质相同当且仅当通过旋转基环可以使它们相同. $n \\le 2 \\times 10^5$. ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/:1:0","tags":null,"title":"[解题报告][luogu5564][Celeste B]Say Goodbye","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/"},{"categories":null,"content":"Solution 旋转基环就是个环同构问题, 那么直接考虑 Burnside 引理. 那么根据一般套路, 可以列出式子 \\[ \\begin{aligned} \\mathrm{ans} \u0026= \\sum_{k = 2}^n \\frac{1}{k} \\sum_{d |k} [\\frac{k}{d} | \\gcd_{i = 1}^m a_i \\wedge \\frac{k}{d} | n]g_{\\frac{n}{k / d}}(d) \\varphi(\\frac{k}{d}) \\\\ \\end{aligned} \\] 其中 \\(g_{n}(m)\\) 为: 环长为 \\(m\\) , 点数为 \\(n\\) 的无标号有序基环树个数. 接下来考虑如何算 \\(g_n(m)\\). 首先考虑节点数为 \\(n\\) 的有根无标号有序树个数怎么算. (不考虑颜色.) 把树的欧拉序看做括号序列, 那么一棵树就唯一地对应一个最外层括号数为 \\(1\\) 的括号序列. (因为要考虑根节点.) 那么方案数也就是第 \\(n - 1\\) 个卡特兰数. 我们设 \\(f_n\\) 为所求方案数, \\(F(x)\\) 为 \\(f_i\\) 的 \\(\\mathrm{OGF}\\). 假设 \\(C(x)\\) 为卡特兰数的 \\(\\mathrm{OGF}\\), 则有 \\(F = xC\\). 再考虑对节点染色. 可以发现染色方案和树的结构是独立的, 所以直接乘上一个染色方案 \\(\\binom{n}{a_1, a_2, \\cdots, a_m}\\) 即可. 那么可以得到 \\[ g_n(k) = [x^n]F^k \\binom{n}{a_1, a_2, \\cdots, a_m} \\] 为了描述更加简洁, 我们默认 \\(\\frac{k}{d} | n\\), 并交换 \\(\\frac{k}{d}\\) 和 \\(d\\). \\[ \\begin{aligned} \\mathrm{ans} \u0026= \\sum_{k = 2}^n \\frac{1}{k} \\sum_{d |k} [d | \\gcd_{i = 1}^m a_i]g_{\\frac{n}{d}}(\\frac{k}{d}) \\varphi(d) \\\\ \u0026= \\sum_{k = 2}^n \\frac{1}{k} \\sum_{d |k} [d | \\gcd_{i = 1}^m a_i][x^{n/d}]F^{k/d}\\binom{n/d}{a_{1 \\cdots m} /d} \\varphi(d) \\\\ \u0026= -f_n \\binom{n}{a_{1 \\cdots m}} + \\sum_{d | \\gcd_{i = 1}^m a_i} \\varphi(d) \\binom{n/d}{a_{1 \\cdots m} /d} [x^{n / d}]\\sum_{t = 1}^{n / d}\\frac{F^{t}}{td} \\\\ \u0026= -f_n \\binom{n}{a_{1 \\cdots m}} + \\sum_{d | \\gcd_{i = 1}^m a_i} \\frac{\\varphi(d)}{d} \\binom{n/d}{a_{1 \\cdots m} /d} [x^{n / d}]\\sum_{t = 1}^{+\\infty}\\frac{F^{t}}{t} \\\\ \\end{aligned} \\] 第二行到第三行是交换枚举顺序, 并用 \\(t\\) 代替 \\(\\frac{k}{d}\\). 接下来有两种推导方法. ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/:2:0","tags":null,"title":"[解题报告][luogu5564][Celeste B]Say Goodbye","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/"},{"categories":null,"content":"一 我们有结论 \\(\\sum_{i = 1}^{+ \\infty} \\frac{x^i}{i} = \\ln(1 - x)\\), 所以原式化为 \\[ \\mathrm{ans} = -f_n \\binom{n}{a_{1 \\cdots m}} + \\sum_{d | \\gcd_{i = 1}^m a_i} \\frac{\\varphi(d)}{d} \\binom{n/d}{a_{1 \\cdots m} /d} [x^{n / d}]\\sum_{t = 1}^{+\\infty}\\ln(1 - F) \\] 多项式 \\(\\ln\\) 求一下即可. 时间复杂度为 \\(O(n \\log n + \\sigma(n))\\). (\\(\\sigma(n)\\) 表示 \\(n\\) 的约数和, 大概是 \\(O(n)\\) 级别的.) ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/:2:1","tags":null,"title":"[解题报告][luogu5564][Celeste B]Say Goodbye","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/"},{"categories":null,"content":"二 卡特兰数生成函数的幂有个性质 \\[ [x^n] C^m = \\binom{2n - m - 1}{n - m} - \\binom{2n - m - 1}{n - m - 1} \\] 然后把这个带进 \\(F^t\\) 即可得到 \\[ \\mathrm{ans} = -f_n \\binom{n}{a_{1 \\cdots m}} + \\sum_{d | \\gcd_{i = 1}^m a_i} \\frac{\\varphi(d)}{d} \\binom{n/d}{a_{1 \\cdots m} /d} \\sum_{t = 1}^{n / d} \\frac{1}{t} \\binom{2n / d - k - 1}{n / d - k} \\binom{2n / d - k - 1}{n / d - k - 1} \\] 时间复杂度为 \\(O(\\sigma(n))\\). ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/:2:2","tags":null,"title":"[解题报告][luogu5564][Celeste B]Say Goodbye","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/"},{"categories":null,"content":"Code #include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003ciostream\u003e using namespace std; const int _ = 4e5 + 7; const int mod = 998244353; int n, m, a[_], gcda; int pri[_], v[_], phi[_], cnt; int fac[_], ifac[_], inv[_]; int Gcd(int a, int b) { return b ? Gcd(b, a % b) : a; } void Init() { cin \u003e\u003e n \u003e\u003e m; gcda = n; for (int i = 1; i \u003c= m; ++i) { scanf(\"%d\", \u0026a[i]); gcda = Gcd(gcda, a[i]); } phi[1] = 1; for (int i = 2; i \u003c= n; ++i) { if (!v[i]) pri[++cnt] = i, v[i] = i, phi[i] = i - 1; for (int j = 1; j \u003c= cnt and pri[j] \u003c= v[i] and i * pri[j] \u003c= n; ++j) { v[i * pri[j]] = pri[j]; phi[i * pri[j]] = (i % pri[j]) ? phi[i] * phi[pri[j]] : phi[i] * pri[j]; } } fac[0] = ifac[0] = inv[1] = 1; for (int i = 1; i \u003c= 2 * n; ++i) { if (i != 1) inv[i] = 1ll * inv[mod % i] * (mod - mod / i ) % mod; fac[i] = 1ll * fac[i - 1] * i % mod; ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod; } } int Ch(int d) { int res = fac[n / d]; assert(!(n % d)); for (int i = 1; i \u003c= m; ++i) res = 1ll * res * ifac[a[i] / d] % mod, assert(!(a[i] % d)); return res; } int C(int n, int m) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; } int main() { Init(); int ans = (mod - 1ll * (C(2 * (n - 1), n - 1) - C(2 * (n - 1), n - 2) + mod) * Ch(1) % mod) % mod; for (int d = 1; d \u003c= gcda; ++d) if (!(gcda % d)) { int res = 0; for (int k = 1; k \u003c= n / d; ++k) res = (res + 1ll * (C(2 * n / d - k - 1, n / d - k) - C(2 * n / d - k - 1, n / d - k - 1) + mod) * inv[k] % mod) % mod; ans = (ans + 1ll * Ch(d) * phi[d] % mod * inv[d] % mod * res % mod) % mod; } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/:3:0","tags":null,"title":"[解题报告][luogu5564][Celeste B]Say Goodbye","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/"},{"categories":null,"content":"Reference 题解 by PinkRabbit ","date":"2021-02-07","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/:4:0","tags":null,"title":"[解题报告][luogu5564][Celeste B]Say Goodbye","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Aluogu5564celeste-bsay-goodbye/"},{"categories":["OI","解题报告"],"content":"题意 若一个拆分方式能把一个串表示为 \\(AABB\\) 的形式, 则称这个拆分为 \"优秀的拆分\". 给定一个串 \\(S\\), 求它所有子串的所有 \"优秀的划分\" 数量总和. \\(T\\) 组数据, \\( T \\le 10,\\ n \\le 30000 \\) ","date":"2021-01-31","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anoi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/:0:1","tags":["解题报告","SA","字符串","NOI","NOI2016"],"title":"[解题报告] [NOI2016]优秀的拆分","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anoi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/"},{"categories":["OI","解题报告"],"content":"解法 首先可以想到在 \\(AA\\) 和 \\(BB\\) 之间的那个位置统计答案, 那么我们就需要对每个位置 \\(i\\) 算出以它为起点 / 终点的形如 \\(AA\\) 的串个数. 计算这个要用到一个 \"撒点\" 的套路. 具体来说就是枚举 \\(AA\\) 的长度 \\(len\\), 然后把原串 \\(S\\) 分为形如 \\([1,len],\\ [len + 1, 2len], \\cdots, [klen + 1, n] \\) 的若干个子串. 然后我们对相邻的子串分别求出它们的 \\(LCP\\) 和 \\(LCS\\) (最长公共前缀和最长公共后缀). 然后稍微画一下就可以找出哪些位置可以作为长度为 \\(2len\\) 的 \\(AA\\) 串的起点或终点, 对于两个相邻的子串来说, 这些点会构成一个区间, 所以用差分实现一下区间加即可. 对于每个 \\(len\\), 处理一次的复杂度是 \\(O(\\frac{n}{len})\\) 的, 所以总复杂度为 \\( O(\\sum_i \\frac{n}{i}) = O(n\\log n) \\). 然后求 \\(LCP\\) 和 \\(LCS\\) 用 SA 或者 SAM 即可. (当然二分加哈希也不是不可以, 不过就是多了个 \\(\\log\\).) ","date":"2021-01-31","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anoi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/:0:2","tags":["解题报告","SA","字符串","NOI","NOI2016"],"title":"[解题报告] [NOI2016]优秀的拆分","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anoi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/"},{"categories":["OI","解题报告"],"content":"代码 #include \u003calgorithm\u003e#include \u003ccassert\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e using namespace std; typedef long long ll; const int _ = 1e5 + 7; const int L = 15; int n, Log[_], f[2][_][L + 7], num[2][_]; char S[_]; int rk[2][_], sa[_], c[_], t[_], trk[_]; void GetSa(bool ty) { for (int i = 0; i \u003c= max(n, (int)'z'); ++i) c[i] = 0; for (int i = 0; i \u003c= 2 * n; ++i) rk[ty][i] = 0; // notice that the upper bound here needs to be 2n for (int i = 1; i \u003c= n; ++i) rk[ty][i] = S[i], ++c[rk[ty][i]]; for (int i = 1; i \u003c= 'z'; ++i) c[i] += c[i - 1]; for (int i = 1; i \u003c= n; ++i) sa[c[rk[ty][i]]--] = i; for (int len = 1; len \u003c n; len \u003c\u003c= 1) { for (int i = 0; i \u003c= n; ++i) c[i] = 0; for (int i = 1; i \u003c= n; ++i) ++c[rk[ty][i]]; for (int i = 1; i \u003c= n; ++i) c[i] += c[i - 1]; for (int i = n; i \u003e= 1; --i) if (sa[i] \u003e len) t[c[rk[ty][sa[i] - len]]--] = sa[i] - len; for (int i = n - len + 1; i \u003c= n; ++i) t[c[rk[ty][i]]--] = i; for (int i = 1; i \u003c= n; ++i) sa[i] = t[i]; int cnt = 0; for (int i = 1; i \u003c= n; ++i) trk[sa[i]] = (i == 1 or rk[ty][sa[i]] != rk[ty][sa[i - 1]] or rk[ty][sa[i] + len] != rk[ty][sa[i - 1] + len]) ? ++cnt : cnt; for (int i = 1; i \u003c= n; ++i) rk[ty][i] = trk[i]; } } int hgt[_]; void GetHgt(bool ty) { for (int i = 0; i \u003c= n; ++i) hgt[i] = 0; for (int i = 1; i \u003c= n; ++i) { int j = sa[rk[ty][i] - 1]; hgt[rk[ty][i]] = max(0, hgt[rk[ty][i - 1]] - 1); while (max(i, j) + hgt[rk[ty][i]] \u003c= n and S[i + hgt[rk[ty][i]]] == S[j + hgt[rk[ty][i]]]) ++hgt[rk[ty][i]]; } for (int i = 1; i \u003c= n; ++i) f[ty][i][0] = hgt[i]; for (int l = 1; l \u003c= L; ++l) for (int i = 1; i + (1 \u003c\u003c (l - 1)) \u003c= n; ++i) f[ty][i][l] = min(f[ty][i][l - 1], f[ty][i + (1 \u003c\u003c (l - 1))][l - 1]); } int Query(bool ty, int l, int r) { assert(l != r); if (ty) l = rk[1][n - l + 1], r = rk[1][n - r + 1]; else l = rk[0][l], r = rk[0][r]; if (l \u003e r) swap(l, r); ++l; int s = Log[r - l + 1]; return min(f[ty][l][s], f[ty][r - (1 \u003c\u003c s) + 1][s]); } int main() { for (int i = 1; i \u003c= 30000; ++i) Log[i] = (i == (1 \u003c\u003c (Log[i - 1] + 1))) ? Log[i - 1] + 1 : Log[i - 1]; int T; cin \u003e\u003e T; while (T--) { scanf(\"%s\", S + 1); n = strlen(S + 1); for (int t = 0; t \u003c 2; ++t) { GetSa(t), GetHgt(t); reverse(S + 1, S + n + 1); } for (int t = 0; t \u003c 2; ++t) for (int i = 1; i \u003c= n; ++i) num[t][i] = 0; for (int l = 1; l \u003c= n; ++l) for (int i = 1; i + 2 * l - 1 \u003c= n; i += l) { int len1 = min(l, Query(1, i + l - 1, i + 2 * l - 1)), len2 = min(l, Query(0, i + l, i + 2 * l)); int p1 = i + l - len1, p2 = min(i + l + len2 - 1, i + 2 * l - 2); if (p1 \u003c= p2 - l + 1) { ++num[1][p1], --num[1][p2 - l + 2]; ++num[0][p1 + 2 * l - 1], --num[0][p2 + l + 1]; } } long long ans = 0; for (int i = 1; i \u003c= n; ++i) num[0][i] += num[0][i - 1], num[1][i] += num[1][i - 1]; for (int i = 1; i \u003c n; ++i) ans += 1ll * num[0][i] * num[1][i + 1]; cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2021-01-31","objectID":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anoi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/:0:3","tags":["解题报告","SA","字符串","NOI","NOI2016"],"title":"[解题报告] [NOI2016]优秀的拆分","uri":"/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8Anoi2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/"},{"categories":null,"content":"配置 ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:1:0","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"用户信息 ~$ git config --global user.name Example ~$ git config --global user.email Example@Example.com ### 编辑器 ```bash ~$ git config --global core.editor emacs ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:1:1","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"基础操作 ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:2:0","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"新建仓库 ~/xxx$ git init ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:2:1","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"拷贝仓库 ~$ git clone https://github.com/BruceW-07/brucew-07.github.io.git ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:2:2","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"跟踪文件 查看仓库状态 ~/xxx$ git status 将文件放入暂存区 ~/xxx$ git add README.md 如果需要将所有文件全部放入暂存区，可以使用参数 -A ~/xxx$ git add -a 但需要注意的是，git add 命令只会将文件放入暂存区，并没有真正提交这次修改。 将文件提交至 Git ~/xxx$ git commit 接下来会弹出一个编辑器窗口，输入 commit 并保存退出即可。 ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:2:3","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"远程操作 将 Git 中信息推送至服务器 例如，将信息推送至 origin 仓库中的 master 分支 ~/xxx$ git push origin master ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/:3:0","tags":null,"title":"Git 学习笔记（简略版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AE%80%E7%95%A5%E7%89%88/"},{"categories":null,"content":"原因 最近又开始尝试搭建自己的博客了，还是 github 托管的方案，不过从 Hexo 换成了 Hugo。 上次尝试失败的原因貌似是不知道怎么将博客迁移到其他电脑上（毕竟我还没有自己的电脑，所以有在机房不同电脑上迁移的需求）。 现在博客的配置已经基本完成了，为防止再次弃坑，打算来系统学一下 Git，顺便丰富一下自己的知识库。 现在是 2021-01-29，星期五，晚上组里休息，那就开始吧。 参考资料 [洛谷日报#199]Git 简单上手指南 by Studying Father ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"配置 ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"用户信息 ~$ git config --global user.name Example ~$ git config --global user.email Example@Example.com 这里的 --global 表示对系统中的所有仓库均有效，如果只想对单个仓库进行配置，只需在仓库的目录下执行去掉 --global 的命令即可。 ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"设置编辑器 ~$ git config --global core.editor emacs ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"基础操作 ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"新建仓库 首先新建一个文件夹作为你的仓库，例如 ~$ mkdir xxx 然后进入这个文件夹，并使用 git init 命令初始化仓库 ~$ cd xxx ~/xxx$ git init Git 将在 ~/xxx 目录中新建一个文件夹 .git。输入指令 ls -a，将会看到 ~/xxx$ ls -a . .. .git ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"拷贝仓库 使用 git clone 命令可以远程拷贝先前创建的仓库，如 ~$ git clone https://github.com/BruceW-07/brucew-07.github.io.git （是的这是我博客部署文件的仓库地址） ","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"跟踪文件 我们对仓库进行了一些修改后，需要将这些修改纳入版本管理中（我将其理解为推送到云备份上）。 而当我们不确定在上一次备份后进行了那些修改时，我们可以使用 git status 命令来查看当前仓库文件的状态。 当我们没有对仓库进行修改时，输入 git status 命令，将会显示以下内容 ~/xxx$ git status On branch master Initial commit nothing to commit (create/copy files and use \"git add\" to track) 而当我们对仓库进行了修改，比如说新建了一个 README.md 文件后，再输入 git status 命令，将会显示 ~/xxx$ touch README.md ~/xxx$ git status On branch master Initial commit Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) README.md nothing added to commit but untracked files present (use \"git add\" to track) 这里 Untracked files 指的是 Git 之前没有纳入版本跟踪的文件。 参考资料中说 如果文件没有纳入版本跟踪，我们对该文件的修改不会被 Git 记录。 不是特别理解，不过大概就那个意思吧。 然后我们可以使用 git add 命令将这个文件纳入版本跟踪 ~/xxx$ git add README.md 这时我们再输入 git status，就会显示 ~/xxx$ git status On branch master Initial commit Changes to be committed: (use \"git rm --cached \u003cfile\u003e...\" to unstage) new file: README.md 表示 README.md 已经纳入了版本跟踪。 但需要注意的是，git add 命令只会将文件放入暂存区，并没有真正提交这次修改，我们需要使用 git commit 命令来将暂存区的文件提交到 Git 上 ~/xxx$ git commit 接下来会弹出一个编辑器窗口，里面显示 # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # On branch master # # Initial commit # # Changes to be committed: # new file: README.md # 我们只需要在第一行输入 commit commit # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # On branch master # # Initial commit # # Changes to be committed: # new file: README.md # 然后保存并退出即可。 终端中便会显示 [master (root-commit) 8c68837] commit 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README.md 表示 README.md 已经成功从暂存区提交到 Git 上了。 我们再使用 git status 命令来查看一下仓库状态 ~/xxx$ git status On branch master nothing to commit, working directory clean 一干二净 我们再来考虑一种情况：对于一个文件 README.md，假如我们先用 git add 命令将它放入暂存区中，这时我们先不使用 git commit 命令提交，而是再修改一下 README.md，然后不把它重新放入暂存区，而是直接提交，会发生什么呢？ 让我们来尝试一下。 先修改一波 README.md ~/xxx$ emacs README.md # 随便写些东西（记得保存） 然后把它放进暂存区 ~/xxx$ git add README.md 检查一下 ~/xxx$ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) modified: README.md 然后再修改一波 ~/xxx$ emacs README.md # 再随便写些东西 看看现在的状态 ~/xxx$ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) modified: README.md Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: README.md 然后现在我们提交，并查看仓库状态 ~/xxx$ git commit # 在弹出的编辑器窗口中输入 \"commit\"，保存并退出 [master ac7a776] commit 1 file changed, 1 insertion(+) ~/xxx$ git status On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: README.md no changes added to commit (use \"git add\" and/or \"git commit -a\") 发现在暂缓区中的 README.md 被提交到 Git 上了，而非暂缓区中的 README.md 仍只保存在本地 我们发现在刚才使用 git status 命令中，有这么两句话 (use \"git reset HEAD \u003cfile\u003e...\" to unstage) 和 (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) 从字面意思以及结合上下文理解上看，第一条命令会使得暂缓区中对 README.md 的修改会被撤回，而第二条命令会使得非暂缓区中对 README.md 的修改被撤销。 我们一个个来试一下。 首先还是先修改 README.md，设内容为 first， 然后 git add， 然后再修改 README.md，设内容为 second， 再输入 git status，显示 ~/xxx$ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) modified: README.md Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: README.md 接着按照它的提示，输入 ~/xxx$ git reset README.md Unstaged changes after reset: M README.md 再输入 git status ~/xxx$ git status On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: README.md no changes added to commit (use \"git add\" and/or \"git commit -a\") 发现暂存区中的 README.md 消失了。打开","date":"2021-01-29","objectID":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","tags":null,"title":"Git 学习笔记（详细版）","uri":"/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]